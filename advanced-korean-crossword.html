<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>단어의 숲 - Word Forest | 한글 크로스워드 자동 생성기</title>
    <style>
        body {
            font-family: 'Malgun Gothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #134e4a 0%, #14b8a6 100%);
            min-height: 100vh;
        }
        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }
        .difficulty-selector {
            background: white;
            padding: 15px 25px;
            border-radius: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .difficulty-selector label {
            margin-right: 10px;
            font-weight: bold;
        }
        .difficulty-selector select {
            padding: 5px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: 2px solid #14b8a6;
            cursor: pointer;
        }
        .container {
            display: flex;
            gap: 40px;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
            justify-content: center;
        }
        #gridContainer {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        #crosswordGrid {
            display: inline-grid;
            gap: 0;
            border: 3px solid #333;
            background: #333;
        }
        .cell {
            width: 35px;
            height: 35px;
            border: 1px solid #666;
            position: relative;
            background: white;
            box-sizing: border-box;
            overflow: hidden;
        }
        .cell.black {
            background: #222;
            border: 1px solid #444;
        }
        .cell.filled {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border: 1px solid #999;
        }
        .cell .number {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 9px;
            font-weight: bold;
            line-height: 1;
            color: #333;
        }
        .cell .letter-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 2px;
        }
        .cell.current {
            background: #ffffcc !important;
            border: 2px solid #14b8a6 !important;
        }
        .cell.selected {
            background: #e6f3ff !important;
        }
        .cell.correct {
            background: #90EE90 !important;
        }
        .cell.incorrect {
            background: #FFB6C1 !important;
        }
        .clues {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            width: 350px;
            max-width: 100%;
            max-height: 500px;
            overflow-y: auto;
        }
        .clues h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 3px solid #14b8a6;
            padding-bottom: 8px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }
        .clue-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .clue-list li {
            padding: 8px 10px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 5px;
            margin: 3px 0;
        }
        .clue-list li:hover {
            background: #f0f0f0;
            transform: translateX(5px);
        }
        .clue-list li.selected {
            background: linear-gradient(135deg, #134e4a 0%, #14b8a6 100%);
            color: white;
            font-weight: bold;
        }
        .clue-number {
            font-weight: bold;
            margin-right: 8px;
            display: inline-block;
            min-width: 25px;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            background: white;
            color: #14b8a6;
            border: 2px solid #14b8a6;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: #14b8a6;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        #controls {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stats {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: flex;
            gap: 30px;
            justify-content: center;
        }
        .stat-item {
            text-align: center;
        }
        .stat-item .value {
            font-size: 24px;
            font-weight: bold;
            color: #14b8a6;
        }
        .stat-item .label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .loading {
            display: none;
            color: white;
            font-size: 18px;
            margin: 20px;
        }
        .loading.active {
            display: block;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid white;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        .answer-input-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            min-width: 400px;
            box-sizing: border-box;
        }
        .answer-input-container.active {
            display: block;
        }
        .answer-input-container h4 {
            margin: 0 0 10px 0;
            color: #14b8a6;
        }
        .answer-input-container .clue-text {
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }
        .answer-input-container input {
            width: 100%;
            padding: 10px;
            font-size: 20px;
            border: 2px solid #14b8a6;
            border-radius: 8px;
            text-align: center;
            letter-spacing: 5px;
            box-sizing: border-box;
        }
        .answer-input-container .buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .answer-input-container button {
            padding: 8px 20px;
            font-size: 14px;
        }

        /* 미디어 쿼리 - 태블릿 */
        @media (max-width: 1200px) {
            .container {
                gap: 20px;
            }
            .clues {
                width: 300px;
            }
            .cell {
                width: 30px;
                height: 30px;
            }
            .cell .letter-display {
                font-size: 16px;
            }
        }

        /* 미디어 쿼리 - 모바일 */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            h1 {
                font-size: 24px;
                margin-bottom: 15px;
            }
            .container {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            #gridContainer {
                padding: 15px;
                width: 100%;
                overflow-x: auto;
            }
            #crosswordGrid {
                margin: 0 auto;
            }
            .clues-container {
                width: 100%;
                flex-direction: column !important;
                align-items: center;
                gap: 15px !important;
            }
            .clues {
                width: 100%;
                max-width: 500px;
                max-height: 300px;
            }
            .cell {
                width: 25px;
                height: 25px;
            }
            .cell .letter-display {
                font-size: 14px;
            }
            .cell .number {
                font-size: 8px;
            }
            #controls {
                flex-direction: column;
                width: 100%;
            }
            button {
                width: 100%;
                margin: 5px 0;
            }
            .stats {
                flex-wrap: wrap;
                gap: 15px;
            }
            .stat-item {
                flex: 1 1 45%;
                min-width: 100px;
            }
            .answer-input-container {
                width: 90%;
                min-width: auto;
                padding: 15px;
            }
            .answer-input-container input {
                font-size: 16px;
                letter-spacing: 2px;
            }
            .difficulty-selector {
                width: 90%;
            }
        }

        /* 미디어 쿼리 - 작은 모바일 */
        @media (max-width: 480px) {
            .cell {
                width: 20px;
                height: 20px;
            }
            .cell .letter-display {
                font-size: 12px;
            }
            .cell .number {
                font-size: 7px;
                top: 1px;
                left: 2px;
            }
            h1 {
                font-size: 20px;
            }
            .clues h3 {
                font-size: 16px;
            }
            .clue-list li {
                font-size: 14px;
                padding: 6px 8px;
            }
            .answer-input-container input {
                font-size: 14px;
                letter-spacing: 1px;
            }
        }
    </style>
</head>
<body>
    <h1>🌲 단어의 숲 - Word Forest 🌲</h1>
    <div style="color: white; text-align: center; margin: -10px 0 10px 0;">
        <div style="font-size: 16px; margin-bottom: 8px; opacity: 0.9;">한글 크로스워드 자동 생성기</div>
        <div style="font-size: 14px;">
            Created by <strong>SunnyBear</strong> |
            <a href="https://wonusdwant.tistory.com" target="_blank" style="color: #86efac; text-decoration: none;">
                wonusdwant.tistory.com
            </a>
        </div>
    </div>

    <div class="difficulty-selector">
        <label for="difficulty">난이도:</label>
        <select id="difficulty" onchange="changeDifficulty()">
            <option value="easy">쉬움 (2-3글자, 15개)</option>
            <option value="medium" selected>보통 (2-4글자, 25개)</option>
            <option value="hard">어려움 (2-5글자, 30개)</option>
            <option value="expert">전문가 (2-5글자, 40개)</option>
        </select>
    </div>

    <div id="controls">
        <button onclick="generateNewPuzzle()">새 퍼즐 생성</button>
        <button onclick="showSolution()">정답 보기</button>
        <button onclick="checkAnswers()">정답 확인</button>
        <button onclick="getHint()">힌트 (1글자)</button>
        <button onclick="clearInputs()">초기화</button>
        <button onclick="loadFromAPI()">사전 단어 추가</button>
    </div>

    <div class="loading" id="loading">
        <span class="spinner"></span>
        단어를 불러오는 중...
    </div>

    <div class="container">
        <div id="gridContainer">
            <div id="crosswordGrid"></div>
        </div>

        <div class="clues-container" style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center;">
            <div class="clues">
                <h3>가로 단어</h3>
                <ul id="acrossClues" class="clue-list"></ul>
            </div>
            <div class="clues">
                <h3>세로 단어</h3>
                <ul id="downClues" class="clue-list"></ul>
            </div>
        </div>
    </div>

    <div class="answer-input-container" id="answerInputContainer">
        <h4 id="inputTitle">단어 입력</h4>
        <div class="clue-text" id="inputClue">힌트가 여기에 표시됩니다</div>
        <input type="text" id="answerInput" placeholder="정답을 입력하세요" maxlength="10">
        <div class="buttons">
            <button onclick="submitAnswer()">확인</button>
            <button onclick="cancelInput()">취소</button>
            <button onclick="clearCurrentWord()">지우기</button>
        </div>
    </div>

    <div class="stats">
        <div class="stat-item">
            <div class="value" id="wordCount">0</div>
            <div class="label">단어 수</div>
        </div>
        <div class="stat-item">
            <div class="value" id="intersectionCount">0</div>
            <div class="label">교차점</div>
        </div>
        <div class="stat-item">
            <div class="value" id="gridSize">0x0</div>
            <div class="label">그리드 크기</div>
        </div>
        <div class="stat-item">
            <div class="value" id="difficultyLevel">보통</div>
            <div class="label">난이도</div>
        </div>
    </div>

    <script>
        // 기본 단어 데이터베이스
        let wordDatabase = [
            // 쉬움 (2글자)
            {word: "사과", clue: "빨간색 과일", difficulty: "easy"},
            {word: "바나", clue: "노란색 열대 과일 ___나", difficulty: "easy"},
            {word: "나비", clue: "꽃에서 꿀을 빠는 곤충", difficulty: "easy"},
            {word: "비밀", clue: "남에게 알리지 않는 것", difficulty: "easy"},
            {word: "가방", clue: "물건을 넣어 들고 다니는 것", difficulty: "easy"},
            {word: "방문", clue: "남의 집을 찾아감", difficulty: "easy"},
            {word: "문어", clue: "다리가 8개인 바다 생물", difficulty: "easy"},
            {word: "어른", clue: "성인", difficulty: "easy"},
            {word: "자리", clue: "앉거나 누울 곳", difficulty: "easy"},
            {word: "리본", clue: "머리에 묶는 장식끈", difficulty: "easy"},
            {word: "본부", clue: "중앙 조직", difficulty: "easy"},
            {word: "부자", clue: "돈이 많은 사람", difficulty: "easy"},
            {word: "자동", clue: "스스로 움직임", difficulty: "easy"},
            {word: "동물", clue: "살아 움직이는 생물", difficulty: "easy"},
            {word: "고기", clue: "육류", difficulty: "easy"},
            {word: "기차", clue: "철로를 달리는 교통수단", difficulty: "easy"},
            {word: "차도", clue: "자동차가 다니는 길", difficulty: "easy"},
            {word: "도시", clue: "서울, 부산 같은 곳", difficulty: "easy"},
            {word: "시장", clue: "물건을 사고파는 곳", difficulty: "easy"},
            {word: "장미", clue: "가시가 있는 꽃", difficulty: "easy"},
            {word: "미술", clue: "그림을 그리는 예술", difficulty: "easy"},
            {word: "술집", clue: "술을 파는 가게", difficulty: "easy"},
            {word: "집안", clue: "가정 내부", difficulty: "easy"},
            {word: "안개", clue: "뿌연 기상 현상", difficulty: "easy"},
            {word: "개미", clue: "부지런한 곤충", difficulty: "easy"},
            {word: "미래", clue: "앞으로 올 시간", difficulty: "easy"},

            // 보통 (3글자)
            {word: "컴퓨터", clue: "PC", difficulty: "medium"},
            {word: "자동차", clue: "네 바퀴 교통수단", difficulty: "medium"},
            {word: "미술관", clue: "그림을 전시하는 곳", difficulty: "medium"},
            {word: "동물원", clue: "동물을 구경하는 곳", difficulty: "medium"},
            {word: "소나무", clue: "사철 푸른 나무", difficulty: "medium"},
            {word: "무지개", clue: "비 온 뒤 하늘의 일곱 색", difficulty: "medium"},
            {word: "개나리", clue: "봄에 피는 노란 꽃", difficulty: "medium"},
            {word: "한국어", clue: "우리나라 말", difficulty: "medium"},
            {word: "태극기", clue: "대한민국 국기", difficulty: "medium"},
            {word: "서울시", clue: "대한민국 수도", difficulty: "medium"},
            {word: "김치찌", clue: "___개, 한국 대표 음식", difficulty: "medium"},

            // 어려움 (4글자)
            {word: "사과나무", clue: "사과가 열리는 나무", difficulty: "hard"},
            {word: "나비효과", clue: "작은 변화가 큰 결과를 만드는 현상", difficulty: "hard"},
            {word: "비밀번호", clue: "암호", difficulty: "hard"},
            {word: "도시계획", clue: "도시를 설계하는 일", difficulty: "hard"},
            {word: "시장경제", clue: "자유로운 거래 체제", difficulty: "hard"},
            {word: "미술작품", clue: "예술가의 창작물", difficulty: "hard"},
            {word: "동물농장", clue: "조지 오웰의 소설", difficulty: "hard"},
            {word: "한글날", clue: "10월 9일", difficulty: "hard"},
            {word: "대한민국", clue: "우리나라 정식 명칭", difficulty: "hard"},

            // 전문가 (5글자+)
            {word: "컴퓨터게임", clue: "PC로 하는 오락", difficulty: "expert"},
            {word: "자동차보험", clue: "차량 사고 대비 상품", difficulty: "expert"},
            {word: "서울특별시", clue: "대한민국 수도의 정식 명칭", difficulty: "expert"},
            {word: "한글창제일", clue: "세종대왕이 한글을 만든 날", difficulty: "expert"},
            {word: "국민건강보험", clue: "의료 보험 제도", difficulty: "expert"},
            {word: "인터넷쇼핑몰", clue: "온라인 쇼핑 사이트", difficulty: "expert"}
        ];

        // API에서 가져온 추가 단어들을 저장
        let apiWords = [];
        let currentDifficulty = 'medium';

        class AdvancedKoreanCrossword {
            constructor(size = 15, difficulty = 'medium') {
                this.size = this.getSizeByDifficulty(difficulty);
                this.difficulty = difficulty;
                this.grid = [];
                this.solution = [];
                this.numbers = [];
                this.acrossWords = [];
                this.downWords = [];
                this.cellNumbers = {};
                this.usedWords = new Set();
                this.intersections = 0;
                this.selectedWord = null;
            }

            getSizeByDifficulty(difficulty) {
                // 화면 크기에 따라 그리드 크기 조정
                const screenWidth = window.innerWidth;
                let baseSize = {
                    'easy': 12,
                    'medium': 15,
                    'hard': 20,
                    'expert': 25
                }[difficulty];

                // 모바일에서는 그리드 크기 축소
                if (screenWidth < 768) {
                    baseSize = Math.min(baseSize, 15);
                }
                if (screenWidth < 480) {
                    baseSize = Math.min(baseSize, 12);
                }

                return baseSize;
            }

            getWordsByDifficulty() {
                const allWords = [...wordDatabase, ...apiWords];
                return allWords.filter(w => {
                    if (this.difficulty === 'easy') return w.word.length >= 2 && w.word.length <= 3;
                    if (this.difficulty === 'medium') return w.word.length >= 2 && w.word.length <= 4;
                    if (this.difficulty === 'hard') return w.word.length >= 2 && w.word.length <= 5; // 어려움: 2-5글자 모두 사용
                    if (this.difficulty === 'expert') return w.word.length >= 2 && w.word.length <= 5; // 전문가: 2-5글자 모두 사용
                    return true;
                });
            }

            generate() {
                this.initGrid();
                this.placeWords();
                this.numberCells();
                this.fillBlackCells();
            }

            initGrid() {
                this.grid = Array(this.size).fill().map(() =>
                    Array(this.size).fill(null)
                );
                this.solution = Array(this.size).fill().map(() =>
                    Array(this.size).fill('')
                );
            }

            placeWords() {
                let availableWords = this.getWordsByDifficulty();

                // 어려움과 전문가 모드에서는 여러 시작점 사용
                if (this.difficulty === 'hard' || this.difficulty === 'expert') {
                    this.placeMultipleStartingWords(availableWords);
                } else {
                    // 첫 단어는 중앙에 가로로 배치
                    const centerRow = Math.floor(this.size / 2);
                    const firstWord = this.selectWord(availableWords,
                        this.difficulty === 'easy' ? 2 : 3,
                        this.difficulty === 'medium' ? 4 : 5
                    );
                    const startCol = Math.floor((this.size - firstWord.word.length) / 2);

                    this.placeWord(firstWord, centerRow, startCol, 'across');
                    availableWords = availableWords.filter(w => w.word !== firstWord.word);
                }

                // 목표 단어 수는 난이도에 따라 (전문가는 현실적으로 조정)
                const targetWords = {
                    'easy': 15,
                    'medium': 25,
                    'hard': 30,
                    'expert': 40
                }[this.difficulty];

                let attempts = 0;
                const maxAttempts = 2000;

                // 어려움/전문가 모드의 경우 저장된 availableWords 사용
                if ((this.difficulty === 'hard' || this.difficulty === 'expert') && this.availableWords) {
                    availableWords = this.availableWords;
                }

                while (this.acrossWords.length + this.downWords.length < targetWords && attempts < maxAttempts) {
                    attempts++;
                    const intersections = this.findPossibleIntersections(availableWords);

                    if (intersections.length === 0) {
                        // 어려움/전문가 모드: 빈 공간에 새로운 단어 그룹 시작
                        if ((this.difficulty === 'hard' || this.difficulty === 'expert') && attempts % 100 === 0) {
                            const randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
                            if (randomWord && this.tryForcePlace(randomWord)) {
                                availableWords = availableWords.filter(w => w.word !== randomWord.word);
                            }
                        }
                        continue;
                    }

                    // 어려움/전문가 모드에서는 다양한 위치 선택
                    if ((this.difficulty === 'hard' || this.difficulty === 'expert') && intersections.length > 5) {
                        // 상위 5개 중에서 랜덤 선택
                        intersections.sort((a, b) => b.score - a.score);
                        const topChoices = intersections.slice(0, 5);
                        const best = topChoices[Math.floor(Math.random() * topChoices.length)];
                        this.placeWord(best.word, best.row, best.col, best.direction);
                        availableWords = availableWords.filter(w => w.word !== best.word.word);
                    } else {
                        intersections.sort((a, b) => b.score - a.score);
                        const best = intersections[0];
                        this.placeWord(best.word, best.row, best.col, best.direction);
                        availableWords = availableWords.filter(w => w.word !== best.word.word);
                    }
                }
            }

            selectWord(words, minLen, maxLen) {
                const filtered = words.filter(w =>
                    w.word.length >= minLen && w.word.length <= maxLen
                );
                return filtered[Math.floor(Math.random() * filtered.length)] || words[0];
            }

            findPossibleIntersections(availableWords) {
                const intersections = [];
                const existingWords = [...this.acrossWords, ...this.downWords];

                for (const existing of existingWords) {
                    for (let i = 0; i < existing.word.word.length; i++) {
                        const letter = existing.word.word[i];

                        for (const candidate of availableWords) {
                            const letterPos = candidate.word.indexOf(letter);
                            if (letterPos === -1) continue;

                            const newDir = existing.direction === 'across' ? 'down' : 'across';

                            let newRow, newCol;
                            if (existing.direction === 'across') {
                                newRow = existing.row - letterPos;
                                newCol = existing.col + i;
                            } else {
                                newRow = existing.row + i;
                                newCol = existing.col - letterPos;
                            }

                            if (this.canPlaceWord(candidate.word, newRow, newCol, newDir)) {
                                const score = this.calculatePlacementScore(candidate.word, newRow, newCol, newDir);
                                if (score > 0) {
                                    intersections.push({
                                        word: candidate,
                                        row: newRow,
                                        col: newCol,
                                        direction: newDir,
                                        score: score
                                    });
                                }
                            }
                        }
                    }
                }

                return intersections;
            }

            canPlaceWord(word, row, col, direction) {
                if (row < 0 || col < 0) return false;
                if (direction === 'across' && col + word.length > this.size) return false;
                if (direction === 'down' && row + word.length > this.size) return false;

                let hasIntersection = false;

                for (let i = 0; i < word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (this.solution[r][c]) {
                        if (this.solution[r][c] !== word[i]) {
                            return false;
                        }
                        hasIntersection = true;
                    }

                    if (direction === 'across') {
                        if (r > 0 && this.solution[r-1][c] && !this.solution[r][c]) return false;
                        if (r < this.size-1 && this.solution[r+1][c] && !this.solution[r][c]) return false;
                    } else {
                        if (c > 0 && this.solution[r][c-1] && !this.solution[r][c]) return false;
                        if (c < this.size-1 && this.solution[r][c+1] && !this.solution[r][c]) return false;
                    }
                }

                if (direction === 'across') {
                    if (col > 0 && this.solution[row][col-1]) return false;
                    if (col + word.length < this.size && this.solution[row][col + word.length]) return false;
                } else {
                    if (row > 0 && this.solution[row-1][col]) return false;
                    if (row + word.length < this.size && this.solution[row + word.length][col]) return false;
                }

                // 전문가 모드에서는 교차점 요구사항 완화
                if (this.difficulty === 'expert' && this.acrossWords.length + this.downWords.length > 30) {
                    return true;
                }

                return true;
            }

            calculatePlacementScore(word, row, col, direction) {
                let score = 0;
                let intersections = 0;

                for (let i = 0; i < word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (this.solution[r][c]) {
                        intersections++;
                        score += 10;
                    }
                }

                if (intersections === 0) return -1;

                const lastR = direction === 'across' ? row : row + word.length - 1;
                const lastC = direction === 'across' ? col + word.length - 1 : col;
                const centerDist = Math.abs(lastR - this.size/2) + Math.abs(lastC - this.size/2);
                score += (this.size - centerDist);
                score += word.length * 2;

                return score;
            }

            placeWord(wordObj, row, col, direction) {
                for (let i = 0; i < wordObj.word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (this.solution[r][c] && this.solution[r][c] === wordObj.word[i]) {
                        this.intersections++;
                    }

                    this.solution[r][c] = wordObj.word[i];
                    this.grid[r][c] = 'letter';
                }

                const wordInfo = {
                    word: wordObj,
                    row: row,
                    col: col,
                    direction: direction,
                    number: 0
                };

                if (direction === 'across') {
                    this.acrossWords.push(wordInfo);
                } else {
                    this.downWords.push(wordInfo);
                }

                this.usedWords.add(wordObj.word);
            }

            numberCells() {
                let number = 1;
                this.numbers = Array(this.size).fill().map(() =>
                    Array(this.size).fill(0)
                );

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] !== 'letter') continue;

                        let needsNumber = false;

                        if ((c === 0 || this.grid[r][c-1] !== 'letter') &&
                            c < this.size - 1 && this.grid[r][c+1] === 'letter') {
                            needsNumber = true;
                            for (const word of this.acrossWords) {
                                if (word.row === r && word.col === c) {
                                    word.number = number;
                                    break;
                                }
                            }
                        }

                        if ((r === 0 || this.grid[r-1][c] !== 'letter') &&
                            r < this.size - 1 && this.grid[r+1][c] === 'letter') {
                            needsNumber = true;
                            for (const word of this.downWords) {
                                if (word.row === r && word.col === c) {
                                    word.number = number;
                                    break;
                                }
                            }
                        }

                        if (needsNumber) {
                            this.numbers[r][c] = number;
                            this.cellNumbers[`${r},${c}`] = number;
                            number++;
                        }
                    }
                }
            }

            placeMultipleStartingWords(availableWords) {
                // 그리드를 구역으로 나누어 각 구역에 시작 단어 배치
                const zones = this.difficulty === 'hard' ?
                    // 어려움 모드: 4개 구역
                    [
                        {row: Math.floor(this.size * 0.25), col: Math.floor(this.size * 0.25)}, // 상단 좌측
                        {row: Math.floor(this.size * 0.25), col: Math.floor(this.size * 0.65)}, // 상단 우측
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.5)}, // 중앙
                        {row: Math.floor(this.size * 0.7), col: Math.floor(this.size * 0.35)}, // 하단
                    ] :
                    // 전문가 모드: 5개 구역
                    [
                        {row: Math.floor(this.size * 0.2), col: Math.floor(this.size * 0.3)}, // 상단
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.2)}, // 중앙 좌측
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.5)}, // 중앙
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.7)}, // 중앙 우측
                        {row: Math.floor(this.size * 0.7), col: Math.floor(this.size * 0.4)}, // 하단
                    ];

                const maxZones = this.difficulty === 'hard' ? 4 : 5;
                for (let i = 0; i < zones.length && i < maxZones; i++) {
                    const zone = zones[i];
                    const word = this.selectWord(availableWords, 3, 5);
                    if (word) {
                        const direction = i % 2 === 0 ? 'across' : 'down';

                        // 구역 내에서 약간의 랜덤 위치 조정
                        const randomOffset = Math.floor(Math.random() * 3) - 1;
                        const adjustedRow = Math.max(0, Math.min(this.size - 5, zone.row + randomOffset));
                        const adjustedCol = Math.max(0, Math.min(this.size - 5, zone.col + randomOffset));

                        if (this.canPlaceWord(word.word, adjustedRow, adjustedCol, direction)) {
                            this.placeWord(word, adjustedRow, adjustedCol, direction);
                            availableWords = availableWords.filter(w => w.word !== word.word);
                        }
                    }
                }

                // 나머지 단어들을 availableWords에 유지
                this.availableWords = availableWords;
            }

            tryForcePlace(wordObj) {
                // 전문가 모드에서 빈 공간 찾아서 배치
                const emptySpots = [];

                // 빈 공간 수집
                for (let r = 1; r < this.size - 1; r += 3) {
                    for (let c = 1; c < this.size - 1; c += 3) {
                        let isEmpty = true;
                        for (let dr = -1; dr <= 1 && isEmpty; dr++) {
                            for (let dc = -1; dc <= 1 && isEmpty; dc++) {
                                if (this.grid[r + dr] && this.grid[r + dr][c + dc]) {
                                    isEmpty = false;
                                }
                            }
                        }
                        if (isEmpty) {
                            emptySpots.push({row: r, col: c});
                        }
                    }
                }

                // 랜덤한 빈 공간에 배치 시도
                const shuffled = emptySpots.sort(() => Math.random() - 0.5);

                for (const spot of shuffled) {
                    // 가로 시도
                    if (spot.col + wordObj.word.length <= this.size) {
                        if (this.canPlaceWordLoose(wordObj.word, spot.row, spot.col, 'across')) {
                            this.placeWord(wordObj, spot.row, spot.col, 'across');
                            return true;
                        }
                    }

                    // 세로 시도
                    if (spot.row + wordObj.word.length <= this.size) {
                        if (this.canPlaceWordLoose(wordObj.word, spot.row, spot.col, 'down')) {
                            this.placeWord(wordObj, spot.row, spot.col, 'down');
                            return true;
                        }
                    }
                }
                return false;
            }

            canPlaceWordLoose(word, row, col, direction) {
                // 더 느슨한 배치 규칙 (전문가 모드용)
                for (let i = 0; i < word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (r < 0 || r >= this.size || c < 0 || c >= this.size) {
                        return false;
                    }

                    if (this.solution[r][c] && this.solution[r][c] !== word[i]) {
                        return false;
                    }
                }
                return true;
            }

            fillBlackCells() {
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] === null) {
                            this.grid[r][c] = 'black';
                        }
                    }
                }
            }

            display() {
                const gridElement = document.getElementById('crosswordGrid');
                gridElement.innerHTML = '';
                gridElement.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        if (this.grid[r][c] === 'black') {
                            cell.className += ' black';
                        } else if (this.grid[r][c] === 'letter') {
                            cell.className += ' filled';

                            if (this.numbers[r][c] > 0) {
                                const number = document.createElement('div');
                                number.className = 'number';
                                number.textContent = this.numbers[r][c];
                                cell.appendChild(number);
                            }

                            const letterDisplay = document.createElement('div');
                            letterDisplay.className = 'letter-display';
                            letterDisplay.dataset.solution = this.solution[r][c];
                            letterDisplay.dataset.row = r;
                            letterDisplay.dataset.col = c;
                            letterDisplay.textContent = ''; // 빈 상태로 시작

                            // 클릭시 해당 단어 선택 및 입력창 열기
                            cell.addEventListener('click', () => this.handleCellClick(r, c));

                            cell.appendChild(letterDisplay);
                        }

                        gridElement.appendChild(cell);
                    }
                }

                this.displayClues();
                this.updateStats();
            }

            handleCellClick(row, col) {
                // 클릭한 셀이 속한 단어 찾기
                let wordFound = null;

                // 가로 단어 확인
                for (const word of this.acrossWords) {
                    if (row === word.row &&
                        col >= word.col &&
                        col < word.col + word.word.word.length) {
                        wordFound = word;
                        break;
                    }
                }

                // 세로 단어 확인
                if (!wordFound) {
                    for (const word of this.downWords) {
                        if (col === word.col &&
                            row >= word.row &&
                            row < word.row + word.word.word.length) {
                            wordFound = word;
                            break;
                        }
                    }
                }

                if (wordFound) {
                    this.highlightWord(wordFound);
                    this.openAnswerInput(wordFound);
                }
            }

            openAnswerInput(word) {
                this.currentInputWord = word;

                const container = document.getElementById('answerInputContainer');
                const title = document.getElementById('inputTitle');
                const clue = document.getElementById('inputClue');
                const input = document.getElementById('answerInput');

                title.textContent = `${word.number}번 ${word.direction === 'across' ? '가로' : '세로'} (${word.word.word.length}글자)`;
                clue.textContent = word.word.clue;
                input.value = this.getCurrentAnswer(word);
                input.maxLength = word.word.word.length;

                container.classList.add('active');
                input.focus();
                input.select();

                // 엔터키로 제출
                input.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        submitAnswer();
                    }
                };
            }

            getCurrentAnswer(word) {
                let answer = '';
                for (let i = 0; i < word.word.word.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"] .letter-display`);
                    if (cell && cell.textContent) {
                        answer += cell.textContent;
                    }
                }
                return answer;
            }

            setWordAnswer(word, answer) {
                for (let i = 0; i < word.word.word.length && i < answer.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"] .letter-display`);
                    if (cell) {
                        cell.textContent = answer[i];
                    }
                }
            }

            displayClues() {
                const acrossClues = document.getElementById('acrossClues');
                acrossClues.innerHTML = '';

                this.acrossWords.sort((a, b) => a.number - b.number);
                for (const word of this.acrossWords) {
                    if (word.number === 0) continue;
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="clue-number">${word.number}.</span> ${word.word.clue}`;
                    li.dataset.number = word.number;
                    li.dataset.direction = 'across';
                    li.onclick = () => this.highlightWord(word);
                    acrossClues.appendChild(li);
                }

                const downClues = document.getElementById('downClues');
                downClues.innerHTML = '';

                this.downWords.sort((a, b) => a.number - b.number);
                for (const word of this.downWords) {
                    if (word.number === 0) continue;
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="clue-number">${word.number}.</span> ${word.word.clue}`;
                    li.dataset.number = word.number;
                    li.dataset.direction = 'down';
                    li.onclick = () => this.highlightWord(word);
                    downClues.appendChild(li);
                }
            }

            highlightWord(word) {
                // 모든 선택 제거
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selected');
                });
                document.querySelectorAll('.clue-list li').forEach(li => {
                    li.classList.remove('selected');
                });

                // 현재 단어 선택
                this.selectedWord = word;

                // 단어 칸들 하이라이트
                for (let i = 0; i < word.word.word.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('selected');
                    }
                }

                // 현재 칸 표시
                for (let i = 0; i < word.word.word.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('current');
                    }
                }

                // 힌트 하이라이트
                const selector = `[data-number="${word.number}"][data-direction="${word.direction}"]`;
                const clueElement = document.querySelector(selector);
                if (clueElement) {
                    clueElement.classList.add('selected');
                    clueElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            updateStats() {
                document.getElementById('wordCount').textContent =
                    this.acrossWords.length + this.downWords.length;
                document.getElementById('intersectionCount').textContent = this.intersections;
                document.getElementById('gridSize').textContent = `${this.size}x${this.size}`;

                const difficultyText = {
                    'easy': '쉬움',
                    'medium': '보통',
                    'hard': '어려움',
                    'expert': '전문가'
                }[this.difficulty];
                document.getElementById('difficultyLevel').textContent = difficultyText;
            }
        }

        let crossword;

        function generateNewPuzzle() {
            const difficulty = document.getElementById('difficulty').value;
            crossword = new AdvancedKoreanCrossword(15, difficulty);
            crossword.generate();
            crossword.display();
        }

        function changeDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            generateNewPuzzle();
        }

        function submitAnswer() {
            const input = document.getElementById('answerInput');
            const answer = input.value.trim();

            if (answer && crossword.currentInputWord) {
                crossword.setWordAnswer(crossword.currentInputWord, answer);
            }

            cancelInput();
        }

        function cancelInput() {
            const container = document.getElementById('answerInputContainer');
            container.classList.remove('active');

            // current 클래스 제거
            document.querySelectorAll('.cell.current').forEach(cell => {
                cell.classList.remove('current');
            });
        }

        function clearCurrentWord() {
            if (crossword.currentInputWord) {
                crossword.setWordAnswer(crossword.currentInputWord, '');
                document.getElementById('answerInput').value = '';
            }
        }

        function showSolution() {
            const cells = document.querySelectorAll('.cell .letter-display');
            cells.forEach(cell => {
                if (cell.dataset.solution) {
                    cell.textContent = cell.dataset.solution;
                    cell.style.color = 'blue';
                }
            });
        }

        function checkAnswers() {
            const cells = document.querySelectorAll('.cell .letter-display');
            let correct = 0;
            let total = 0;

            cells.forEach(cell => {
                if (cell.dataset.solution) {
                    total++;
                    cell.parentElement.classList.remove('correct', 'incorrect');
                    if (cell.textContent === cell.dataset.solution) {
                        cell.parentElement.classList.add('correct');
                        correct++;
                    } else if (cell.textContent) {
                        cell.parentElement.classList.add('incorrect');
                    }
                }
            });

            setTimeout(() => {
                alert(`정답: ${correct}/${total} (${Math.round(correct/total*100)}%)`);
            }, 100);
        }

        function getHint() {
            const cells = document.querySelectorAll('.cell .letter-display');
            const emptyCells = Array.from(cells).filter(cell =>
                cell.dataset.solution && !cell.textContent
            );

            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                randomCell.textContent = randomCell.dataset.solution;
                randomCell.style.color = 'green';
            } else {
                alert('모든 칸이 채워져 있습니다!');
            }
        }

        function clearInputs() {
            const cells = document.querySelectorAll('.cell .letter-display');
            cells.forEach(cell => {
                cell.textContent = '';
                cell.style.color = '';
                cell.parentElement.classList.remove('correct', 'incorrect');
            });

            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('selected', 'current');
            });
            document.querySelectorAll('.clue-list li').forEach(li => {
                li.classList.remove('selected');
            });

            cancelInput();
        }

        async function loadFromAPI() {
            const loading = document.getElementById('loading');
            loading.classList.add('active');

            try {
                // API 키가 없으면 로컬 단어 추가
                const apiKey = 'YOUR_API_KEY_HERE'; // 환경변수나 서버에서 관리

                if (apiKey === 'YOUR_API_KEY_HERE') {
                    // API 키 없을 때 대체 단어 추가
                    addFallbackWords();
                    loading.classList.remove('active');
                    alert('샘플 단어 50개를 추가했습니다!');
                    generateNewPuzzle();
                    return;
                }
                const searchWords = ['학교', '컴퓨터', '인터넷', '한국', '서울', '음악', '영화', '운동', '사랑', '친구', '가족', '음식'];

                for (const searchWord of searchWords) {
                    try {
                        // 국립국어원 API 호출
                        const response = await fetch(`https://krdict.korean.go.kr/api/search?key=${apiKey}&q=${searchWord}&num=20&advanced=y&method=exact&type1=word&type3=general`);

                        if (response.ok) {
                            const data = await response.text();
                            // XML 파싱
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(data, "text/xml");
                            const items = xmlDoc.getElementsByTagName('item');

                            for (let i = 0; i < Math.min(items.length, 10); i++) {
                                const wordElement = items[i].getElementsByTagName('word')[0];
                                const senseElement = items[i].getElementsByTagName('sense')[0];

                                if (wordElement && senseElement) {
                                    const word = wordElement.textContent.replace(/-/g, '').replace(/\^/g, '');
                                    const definition = senseElement.getElementsByTagName('definition')[0];

                                    if (word && definition && word.length >= 2 && word.length <= 8) {
                                        const clue = definition.textContent.split('.')[0].substring(0, 30);

                                        // 난이도 자동 설정
                                        let difficulty = 'easy';
                                        if (word.length >= 6) difficulty = 'expert';
                                        else if (word.length >= 5) difficulty = 'hard';
                                        else if (word.length >= 4) difficulty = 'medium';

                                        const newWord = {
                                            word: word,
                                            clue: clue || `${searchWord} 관련 단어`,
                                            difficulty: difficulty
                                        };

                                        // 중복 확인 후 추가
                                        if (!wordDatabase.some(w => w.word === newWord.word) &&
                                            !apiWords.some(w => w.word === newWord.word)) {
                                            apiWords.push(newWord);
                                        }
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.log(`Failed to fetch ${searchWord}:`, err);
                    }

                    // 백업용 샘플 데이터
                    const sampleWords = [
                        {word: "학교생활", clue: "학생들의 일상", difficulty: "hard"},
                        {word: "컴퓨터실", clue: "PC가 있는 교실", difficulty: "hard"},
                        {word: "인터넷망", clue: "온라인 네트워크", difficulty: "hard"},
                        {word: "한국문화", clue: "우리나라의 전통과 현대", difficulty: "hard"},
                        {word: "서울역", clue: "수도의 중앙 기차역", difficulty: "medium"},
                        {word: "음악회", clue: "연주를 듣는 행사", difficulty: "medium"},
                        {word: "영화관", clue: "영화를 보는 곳", difficulty: "medium"},
                        {word: "운동장", clue: "체육 활동을 하는 곳", difficulty: "medium"},
                        {word: "도서관", clue: "책을 빌리는 곳", difficulty: "medium"},
                        {word: "병원", clue: "아픈 사람을 치료하는 곳", difficulty: "easy"},
                        {word: "은행", clue: "돈을 맡기는 곳", difficulty: "easy"},
                        {word: "우체국", clue: "편지를 보내는 곳", difficulty: "medium"},
                        {word: "경찰서", clue: "치안을 담당하는 곳", difficulty: "medium"},
                        {word: "소방서", clue: "화재를 진압하는 곳", difficulty: "medium"},
                        {word: "대학교", clue: "고등교육 기관", difficulty: "medium"},
                        {word: "초등학교", clue: "어린이들이 다니는 학교", difficulty: "hard"},
                        {word: "중학교", clue: "초등학교 다음 과정", difficulty: "medium"},
                        {word: "고등학교", clue: "대학 전 교육과정", difficulty: "hard"},
                        {word: "유치원", clue: "미취학 아동 교육기관", difficulty: "medium"},
                        {word: "놀이터", clue: "아이들이 노는 곳", difficulty: "medium"}
                    ];

                    // 중복 제거 후 추가
                    sampleWords.forEach(newWord => {
                        if (!wordDatabase.some(w => w.word === newWord.word) &&
                            !apiWords.some(w => w.word === newWord.word)) {
                            apiWords.push(newWord);
                        }
                    });
                }

                loading.classList.remove('active');
                alert(`${apiWords.length}개의 새로운 단어를 추가했습니다!`);
                generateNewPuzzle();

            } catch (error) {
                console.error('API 로드 실패:', error);
                loading.classList.remove('active');
                alert('단어 불러오기에 실패했습니다. 샘플 단어를 추가합니다.');

                // 오류시에도 샘플 단어 추가
                const fallbackWords = [
                    {word: "봄날", clue: "따뜻한 계절의 하루", difficulty: "easy"},
                    {word: "여름밤", clue: "더운 계절의 저녁", difficulty: "medium"},
                    {word: "가을비", clue: "단풍 계절의 강수", difficulty: "medium"},
                    {word: "겨울잠", clue: "동물의 동면", difficulty: "medium"}
                ];
                fallbackWords.forEach(word => {
                    if (!wordDatabase.some(w => w.word === word.word)) {
                        apiWords.push(word);
                    }
                });
                generateNewPuzzle();
            }
        }

        // 개발자 콘솔 메시지
        console.log('%c🌲 단어의 숲 - Word Forest 🌲', 'background: linear-gradient(135deg, #134e4a, #14b8a6); color: white; font-size: 20px; padding: 10px; border-radius: 5px; font-weight: bold;');
        console.log('%cCreated by SunnyBear', 'color: #14b8a6; font-size: 16px; font-weight: bold;');
        console.log('%c📝 Blog: https://wonusdwant.tistory.com', 'color: #134e4a; font-size: 14px;');
        console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #14b8a6;');
        console.log('%c💡 Features:', 'color: #14b8a6; font-size: 14px; font-weight: bold;');
        console.log('%c• Multi-cluster crossword generation', 'color: #333; font-size: 12px;');
        console.log('%c• Korean language optimized input system', 'color: #333; font-size: 12px;');
        console.log('%c• Dynamic difficulty adjustment', 'color: #333; font-size: 12px;');
        console.log('%c• National Korean Dictionary API integration', 'color: #333; font-size: 12px;');
        console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #14b8a6;');
        console.log('%c© 2025 SunnyBear. All rights reserved.', 'color: #999; font-size: 12px;');
        console.log('%cDeveloped with ❤️ at wonusdwant.tistory.com', 'color: #999; font-size: 12px;');

        // ASCII 아트 추가
        console.log(`%c
    ʕ•ᴥ•ʔ
   SunnyBear
  `, 'color: #14b8a6; font-family: monospace;');

        // API 없을 때 대체 단어 함수
        function addFallbackWords() {
            const extraWords = [
                {word: "학교", clue: "학생들이 공부하는 곳", difficulty: "easy"},
                {word: "친구", clue: "함께 노는 사람", difficulty: "easy"},
                {word: "가족", clue: "엄마 아빠와 함께", difficulty: "easy"},
                {word: "선생", clue: "가르치는 분", difficulty: "easy"},
                {word: "컴퓨", clue: "___터, PC", difficulty: "easy"},
                {word: "휴대", clue: "___폰", difficulty: "easy"},
                {word: "자전", clue: "___거, 페달", difficulty: "easy"},
                {word: "놀이", clue: "___공원", difficulty: "easy"},
                {word: "생일", clue: "케이크 먹는 날", difficulty: "easy"},
                {word: "김치", clue: "한국 발효 음식", difficulty: "easy"},
                {word: "한복", clue: "전통 의상", difficulty: "easy"},
                {word: "불고", clue: "___기, 달콤한 고기", difficulty: "easy"},
                {word: "떡볶", clue: "___이, 매운 떡", difficulty: "easy"},
                {word: "비빔", clue: "___밥", difficulty: "easy"},
                {word: "삼겹", clue: "___살", difficulty: "easy"},
                {word: "잡채", clue: "당면 요리", difficulty: "easy"},
                {word: "갈비", clue: "소갈비 구이", difficulty: "easy"},
                {word: "냉면", clue: "차가운 국수", difficulty: "easy"},
                {word: "파전", clue: "파로 만든 전", difficulty: "easy"},
                {word: "호떡", clue: "달콤한 간식", difficulty: "easy"},
                {word: "붕어", clue: "___빵", difficulty: "easy"},
                {word: "계란", clue: "달걀", difficulty: "easy"},
                {word: "미역", clue: "생일날 국", difficulty: "easy"},
                {word: "감자", clue: "___탕", difficulty: "easy"},
                {word: "순대", clue: "돼지 창자 요리", difficulty: "easy"},
                {word: "곰탕", clue: "소뼈 국물", difficulty: "easy"},
                {word: "오징", clue: "___어, 다리 10개", difficulty: "easy"},
                {word: "고등", clue: "___어, 등푸른 생선", difficulty: "easy"},
                {word: "갈치", clue: "긴 은색 생선", difficulty: "easy"},
                {word: "연어", clue: "주황색 생선", difficulty: "easy"},
                {word: "광어", clue: "납작한 생선", difficulty: "easy"},
                {word: "우럭", clue: "매운탕 생선", difficulty: "easy"},
                {word: "농어", clue: "흰살 생선", difficulty: "easy"},
                {word: "도미", clue: "빨간 생선", difficulty: "easy"},
                {word: "복어", clue: "독 있는 생선", difficulty: "easy"},
                {word: "낙지", clue: "다리 8개", difficulty: "easy"},
                {word: "새우", clue: "구부러진 해산물", difficulty: "easy"},
                {word: "게", clue: "집게발", difficulty: "easy"},
                {word: "조개", clue: "껍데기 해산물", difficulty: "easy"},
                {word: "전복", clue: "귀한 조개", difficulty: "easy"},
                {word: "굴", clue: "바다의 우유", difficulty: "easy"},
                {word: "멍게", clue: "울퉁불퉁 해산물", difficulty: "easy"},
                {word: "한글", clue: "우리 글자", difficulty: "easy"},
                {word: "세종", clue: "한글 만든 왕", difficulty: "easy"},
                {word: "서울", clue: "수도", difficulty: "easy"},
                {word: "부산", clue: "제2도시", difficulty: "easy"},
                {word: "인천", clue: "공항 도시", difficulty: "easy"},
                {word: "대구", clue: "경북 중심도시", difficulty: "easy"},
                {word: "대전", clue: "충청 중심도시", difficulty: "easy"},
                {word: "광주", clue: "전남 중심도시", difficulty: "easy"}
            ];

            extraWords.forEach(word => {
                if (!wordDatabase.some(w => w.word === word.word) &&
                    !apiWords.some(w => w.word === word.word)) {
                    apiWords.push(word);
                }
            });
        }

        // 페이지 로드시 퍼즐 생성
        window.onload = function() {
            // 기본 단어 추가로 API 없이도 충분히 작동
            addFallbackWords();
            generateNewPuzzle();
        };
    </script>

    <!-- Footer with credits -->
    <div style="text-align: center; margin-top: 30px; padding: 20px; color: white; font-size: 12px;">
        <div>
            🐻 Developed by <strong>SunnyBear</strong> |
            <a href="https://wonusdwant.tistory.com" target="_blank" style="color: #86efac;">Blog</a> |
            © 2025 All Rights Reserved
        </div>
        <div style="margin-top: 10px; opacity: 0.8;">
            단어의 숲 (Word Forest) v1.0 | Multi-Cluster Algorithm | Since 2025
        </div>
    </div>
</body>
</html>