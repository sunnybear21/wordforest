<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë‹¨ì–´ì˜ ìˆ² - Word Forest | í•œê¸€ í¬ë¡œìŠ¤ì›Œë“œ ìë™ ìƒì„±ê¸°</title>
    <style>
        body {
            font-family: 'Malgun Gothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #134e4a 0%, #14b8a6 100%);
            min-height: 100vh;
        }
        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }
        .difficulty-selector {
            background: white;
            padding: 15px 25px;
            border-radius: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .difficulty-selector label {
            margin-right: 10px;
            font-weight: bold;
        }
        .difficulty-selector select {
            padding: 5px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: 2px solid #14b8a6;
            cursor: pointer;
        }
        .container {
            display: flex;
            gap: 40px;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
            justify-content: center;
        }
        #gridContainer {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        #crosswordGrid {
            display: inline-grid;
            gap: 0;
            border: 3px solid #333;
            background: #333;
        }
        .cell {
            width: 35px;
            height: 35px;
            border: 1px solid #666;
            position: relative;
            background: white;
            box-sizing: border-box;
            overflow: hidden;
        }
        .cell.black {
            background: #222;
            border: 1px solid #444;
        }
        .cell.filled {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border: 1px solid #999;
        }
        .cell .number {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 9px;
            font-weight: bold;
            line-height: 1;
            color: #333;
        }
        .cell .letter-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 2px;
        }
        .cell.current {
            background: #ffffcc !important;
            border: 2px solid #14b8a6 !important;
        }
        .cell.selected {
            background: #e6f3ff !important;
        }
        .cell.correct {
            background: #90EE90 !important;
        }
        .cell.incorrect {
            background: #FFB6C1 !important;
        }
        .clues {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            width: 350px;
            max-width: 100%;
            max-height: 500px;
            overflow-y: auto;
        }
        .clues h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 3px solid #14b8a6;
            padding-bottom: 8px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }
        .clue-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .clue-list li {
            padding: 8px 10px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 5px;
            margin: 3px 0;
        }
        .clue-list li:hover {
            background: #f0f0f0;
            transform: translateX(5px);
        }
        .clue-list li.selected {
            background: linear-gradient(135deg, #134e4a 0%, #14b8a6 100%);
            color: white;
            font-weight: bold;
        }
        .clue-number {
            font-weight: bold;
            margin-right: 8px;
            display: inline-block;
            min-width: 25px;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            background: white;
            color: #14b8a6;
            border: 2px solid #14b8a6;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: #14b8a6;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        #controls {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stats {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: flex;
            gap: 30px;
            justify-content: center;
        }
        .stat-item {
            text-align: center;
        }
        .stat-item .value {
            font-size: 24px;
            font-weight: bold;
            color: #14b8a6;
        }
        .stat-item .label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .loading {
            display: none;
            color: white;
            font-size: 18px;
            margin: 20px;
        }
        .loading.active {
            display: block;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid white;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        .answer-input-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            min-width: 400px;
            box-sizing: border-box;
        }
        .answer-input-container.active {
            display: block;
        }
        .answer-input-container h4 {
            margin: 0 0 10px 0;
            color: #14b8a6;
        }
        .answer-input-container .clue-text {
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
        }
        .answer-input-container input {
            width: 100%;
            padding: 10px;
            font-size: 20px;
            border: 2px solid #14b8a6;
            border-radius: 8px;
            text-align: center;
            letter-spacing: 5px;
            box-sizing: border-box;
        }
        .answer-input-container .buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .answer-input-container button {
            padding: 8px 20px;
            font-size: 14px;
        }

        /* ë¯¸ë””ì–´ ì¿¼ë¦¬ - íƒœë¸”ë¦¿ */
        @media (max-width: 1200px) {
            .container {
                gap: 20px;
            }
            .clues {
                width: 300px;
            }
            .cell {
                width: 30px;
                height: 30px;
            }
            .cell .letter-display {
                font-size: 16px;
            }
        }

        /* ë¯¸ë””ì–´ ì¿¼ë¦¬ - ëª¨ë°”ì¼ */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            h1 {
                font-size: 24px;
                margin-bottom: 15px;
            }
            .container {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            #gridContainer {
                padding: 15px;
                width: 100%;
                overflow-x: auto;
            }
            #crosswordGrid {
                margin: 0 auto;
            }
            .clues-container {
                width: 100%;
                flex-direction: column !important;
                align-items: center;
                gap: 15px !important;
            }
            .clues {
                width: 100%;
                max-width: 500px;
                max-height: 300px;
            }
            .cell {
                width: 25px;
                height: 25px;
            }
            .cell .letter-display {
                font-size: 14px;
            }
            .cell .number {
                font-size: 8px;
            }
            #controls {
                flex-direction: column;
                width: 100%;
            }
            button {
                width: 100%;
                margin: 5px 0;
            }
            .stats {
                flex-wrap: wrap;
                gap: 15px;
            }
            .stat-item {
                flex: 1 1 45%;
                min-width: 100px;
            }
            .answer-input-container {
                width: 90%;
                min-width: auto;
                padding: 15px;
            }
            .answer-input-container input {
                font-size: 16px;
                letter-spacing: 2px;
            }
            .difficulty-selector {
                width: 90%;
            }
        }

        /* ë¯¸ë””ì–´ ì¿¼ë¦¬ - ì‘ì€ ëª¨ë°”ì¼ */
        @media (max-width: 480px) {
            .cell {
                width: 20px;
                height: 20px;
            }
            .cell .letter-display {
                font-size: 12px;
            }
            .cell .number {
                font-size: 7px;
                top: 1px;
                left: 2px;
            }
            h1 {
                font-size: 20px;
            }
            .clues h3 {
                font-size: 16px;
            }
            .clue-list li {
                font-size: 14px;
                padding: 6px 8px;
            }
            .answer-input-container input {
                font-size: 14px;
                letter-spacing: 1px;
            }
        }
    </style>
</head>
<body>
    <h1>ğŸŒ² ë‹¨ì–´ì˜ ìˆ² - Word Forest ğŸŒ²</h1>
    <div style="color: white; text-align: center; margin: -10px 0 10px 0;">
        <div style="font-size: 16px; margin-bottom: 8px; opacity: 0.9;">í•œê¸€ í¬ë¡œìŠ¤ì›Œë“œ ìë™ ìƒì„±ê¸°</div>
        <div style="font-size: 14px;">
            Created by <strong>SunnyBear</strong> |
            <a href="https://wonusdwant.tistory.com" target="_blank" style="color: #86efac; text-decoration: none;">
                wonusdwant.tistory.com
            </a>
        </div>
    </div>

    <div class="difficulty-selector">
        <label for="difficulty">ë‚œì´ë„:</label>
        <select id="difficulty" onchange="changeDifficulty()">
            <option value="easy">ì‰¬ì›€ (2-3ê¸€ì, 15ê°œ)</option>
            <option value="medium" selected>ë³´í†µ (2-4ê¸€ì, 25ê°œ)</option>
            <option value="hard">ì–´ë ¤ì›€ (2-5ê¸€ì, 30ê°œ)</option>
            <option value="expert">ì „ë¬¸ê°€ (2-5ê¸€ì, 40ê°œ)</option>
        </select>
    </div>

    <div id="controls">
        <button onclick="generateNewPuzzle()">ìƒˆ í¼ì¦ ìƒì„±</button>
        <button onclick="showSolution()">ì •ë‹µ ë³´ê¸°</button>
        <button onclick="checkAnswers()">ì •ë‹µ í™•ì¸</button>
        <button onclick="getHint()">íŒíŠ¸ (1ê¸€ì)</button>
        <button onclick="clearInputs()">ì´ˆê¸°í™”</button>
        <button onclick="loadFromAPI()">ì‚¬ì „ ë‹¨ì–´ ì¶”ê°€</button>
    </div>

    <div class="loading" id="loading">
        <span class="spinner"></span>
        ë‹¨ì–´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
    </div>

    <div class="container">
        <div id="gridContainer">
            <div id="crosswordGrid"></div>
        </div>

        <div class="clues-container" style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center;">
            <div class="clues">
                <h3>ê°€ë¡œ ë‹¨ì–´</h3>
                <ul id="acrossClues" class="clue-list"></ul>
            </div>
            <div class="clues">
                <h3>ì„¸ë¡œ ë‹¨ì–´</h3>
                <ul id="downClues" class="clue-list"></ul>
            </div>
        </div>
    </div>

    <div class="answer-input-container" id="answerInputContainer">
        <h4 id="inputTitle">ë‹¨ì–´ ì…ë ¥</h4>
        <div class="clue-text" id="inputClue">íŒíŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
        <input type="text" id="answerInput" placeholder="ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
        <div class="buttons">
            <button onclick="submitAnswer()">í™•ì¸</button>
            <button onclick="cancelInput()">ì·¨ì†Œ</button>
            <button onclick="clearCurrentWord()">ì§€ìš°ê¸°</button>
        </div>
    </div>

    <div class="stats">
        <div class="stat-item">
            <div class="value" id="wordCount">0</div>
            <div class="label">ë‹¨ì–´ ìˆ˜</div>
        </div>
        <div class="stat-item">
            <div class="value" id="intersectionCount">0</div>
            <div class="label">êµì°¨ì </div>
        </div>
        <div class="stat-item">
            <div class="value" id="gridSize">0x0</div>
            <div class="label">ê·¸ë¦¬ë“œ í¬ê¸°</div>
        </div>
        <div class="stat-item">
            <div class="value" id="difficultyLevel">ë³´í†µ</div>
            <div class="label">ë‚œì´ë„</div>
        </div>
    </div>

    <script>
        // ê¸°ë³¸ ë‹¨ì–´ ë°ì´í„°ë² ì´ìŠ¤
        let wordDatabase = [
            // ì‰¬ì›€ (2ê¸€ì)
            {word: "ì‚¬ê³¼", clue: "ë¹¨ê°„ìƒ‰ ê³¼ì¼", difficulty: "easy"},
            {word: "ë°”ë‚˜", clue: "ë…¸ë€ìƒ‰ ì—´ëŒ€ ê³¼ì¼ ___ë‚˜", difficulty: "easy"},
            {word: "ë‚˜ë¹„", clue: "ê½ƒì—ì„œ ê¿€ì„ ë¹ ëŠ” ê³¤ì¶©", difficulty: "easy"},
            {word: "ë¹„ë°€", clue: "ë‚¨ì—ê²Œ ì•Œë¦¬ì§€ ì•ŠëŠ” ê²ƒ", difficulty: "easy"},
            {word: "ê°€ë°©", clue: "ë¬¼ê±´ì„ ë„£ì–´ ë“¤ê³  ë‹¤ë‹ˆëŠ” ê²ƒ", difficulty: "easy"},
            {word: "ë°©ë¬¸", clue: "ë‚¨ì˜ ì§‘ì„ ì°¾ì•„ê°", difficulty: "easy"},
            {word: "ë¬¸ì–´", clue: "ë‹¤ë¦¬ê°€ 8ê°œì¸ ë°”ë‹¤ ìƒë¬¼", difficulty: "easy"},
            {word: "ì–´ë¥¸", clue: "ì„±ì¸", difficulty: "easy"},
            {word: "ìë¦¬", clue: "ì•‰ê±°ë‚˜ ëˆ„ìš¸ ê³³", difficulty: "easy"},
            {word: "ë¦¬ë³¸", clue: "ë¨¸ë¦¬ì— ë¬¶ëŠ” ì¥ì‹ëˆ", difficulty: "easy"},
            {word: "ë³¸ë¶€", clue: "ì¤‘ì•™ ì¡°ì§", difficulty: "easy"},
            {word: "ë¶€ì", clue: "ëˆì´ ë§ì€ ì‚¬ëŒ", difficulty: "easy"},
            {word: "ìë™", clue: "ìŠ¤ìŠ¤ë¡œ ì›€ì§ì„", difficulty: "easy"},
            {word: "ë™ë¬¼", clue: "ì‚´ì•„ ì›€ì§ì´ëŠ” ìƒë¬¼", difficulty: "easy"},
            {word: "ê³ ê¸°", clue: "ìœ¡ë¥˜", difficulty: "easy"},
            {word: "ê¸°ì°¨", clue: "ì² ë¡œë¥¼ ë‹¬ë¦¬ëŠ” êµí†µìˆ˜ë‹¨", difficulty: "easy"},
            {word: "ì°¨ë„", clue: "ìë™ì°¨ê°€ ë‹¤ë‹ˆëŠ” ê¸¸", difficulty: "easy"},
            {word: "ë„ì‹œ", clue: "ì„œìš¸, ë¶€ì‚° ê°™ì€ ê³³", difficulty: "easy"},
            {word: "ì‹œì¥", clue: "ë¬¼ê±´ì„ ì‚¬ê³ íŒŒëŠ” ê³³", difficulty: "easy"},
            {word: "ì¥ë¯¸", clue: "ê°€ì‹œê°€ ìˆëŠ” ê½ƒ", difficulty: "easy"},
            {word: "ë¯¸ìˆ ", clue: "ê·¸ë¦¼ì„ ê·¸ë¦¬ëŠ” ì˜ˆìˆ ", difficulty: "easy"},
            {word: "ìˆ ì§‘", clue: "ìˆ ì„ íŒŒëŠ” ê°€ê²Œ", difficulty: "easy"},
            {word: "ì§‘ì•ˆ", clue: "ê°€ì • ë‚´ë¶€", difficulty: "easy"},
            {word: "ì•ˆê°œ", clue: "ë¿Œì—° ê¸°ìƒ í˜„ìƒ", difficulty: "easy"},
            {word: "ê°œë¯¸", clue: "ë¶€ì§€ëŸ°í•œ ê³¤ì¶©", difficulty: "easy"},
            {word: "ë¯¸ë˜", clue: "ì•ìœ¼ë¡œ ì˜¬ ì‹œê°„", difficulty: "easy"},

            // ë³´í†µ (3ê¸€ì)
            {word: "ì»´í“¨í„°", clue: "PC", difficulty: "medium"},
            {word: "ìë™ì°¨", clue: "ë„¤ ë°”í€´ êµí†µìˆ˜ë‹¨", difficulty: "medium"},
            {word: "ë¯¸ìˆ ê´€", clue: "ê·¸ë¦¼ì„ ì „ì‹œí•˜ëŠ” ê³³", difficulty: "medium"},
            {word: "ë™ë¬¼ì›", clue: "ë™ë¬¼ì„ êµ¬ê²½í•˜ëŠ” ê³³", difficulty: "medium"},
            {word: "ì†Œë‚˜ë¬´", clue: "ì‚¬ì²  í‘¸ë¥¸ ë‚˜ë¬´", difficulty: "medium"},
            {word: "ë¬´ì§€ê°œ", clue: "ë¹„ ì˜¨ ë’¤ í•˜ëŠ˜ì˜ ì¼ê³± ìƒ‰", difficulty: "medium"},
            {word: "ê°œë‚˜ë¦¬", clue: "ë´„ì— í”¼ëŠ” ë…¸ë€ ê½ƒ", difficulty: "medium"},
            {word: "í•œêµ­ì–´", clue: "ìš°ë¦¬ë‚˜ë¼ ë§", difficulty: "medium"},
            {word: "íƒœê·¹ê¸°", clue: "ëŒ€í•œë¯¼êµ­ êµ­ê¸°", difficulty: "medium"},
            {word: "ì„œìš¸ì‹œ", clue: "ëŒ€í•œë¯¼êµ­ ìˆ˜ë„", difficulty: "medium"},
            {word: "ê¹€ì¹˜ì°Œ", clue: "___ê°œ, í•œêµ­ ëŒ€í‘œ ìŒì‹", difficulty: "medium"},

            // ì–´ë ¤ì›€ (4ê¸€ì)
            {word: "ì‚¬ê³¼ë‚˜ë¬´", clue: "ì‚¬ê³¼ê°€ ì—´ë¦¬ëŠ” ë‚˜ë¬´", difficulty: "hard"},
            {word: "ë‚˜ë¹„íš¨ê³¼", clue: "ì‘ì€ ë³€í™”ê°€ í° ê²°ê³¼ë¥¼ ë§Œë“œëŠ” í˜„ìƒ", difficulty: "hard"},
            {word: "ë¹„ë°€ë²ˆí˜¸", clue: "ì•”í˜¸", difficulty: "hard"},
            {word: "ë„ì‹œê³„íš", clue: "ë„ì‹œë¥¼ ì„¤ê³„í•˜ëŠ” ì¼", difficulty: "hard"},
            {word: "ì‹œì¥ê²½ì œ", clue: "ììœ ë¡œìš´ ê±°ë˜ ì²´ì œ", difficulty: "hard"},
            {word: "ë¯¸ìˆ ì‘í’ˆ", clue: "ì˜ˆìˆ ê°€ì˜ ì°½ì‘ë¬¼", difficulty: "hard"},
            {word: "ë™ë¬¼ë†ì¥", clue: "ì¡°ì§€ ì˜¤ì›°ì˜ ì†Œì„¤", difficulty: "hard"},
            {word: "í•œê¸€ë‚ ", clue: "10ì›” 9ì¼", difficulty: "hard"},
            {word: "ëŒ€í•œë¯¼êµ­", clue: "ìš°ë¦¬ë‚˜ë¼ ì •ì‹ ëª…ì¹­", difficulty: "hard"},

            // ì „ë¬¸ê°€ (5ê¸€ì+)
            {word: "ì»´í“¨í„°ê²Œì„", clue: "PCë¡œ í•˜ëŠ” ì˜¤ë½", difficulty: "expert"},
            {word: "ìë™ì°¨ë³´í—˜", clue: "ì°¨ëŸ‰ ì‚¬ê³  ëŒ€ë¹„ ìƒí’ˆ", difficulty: "expert"},
            {word: "ì„œìš¸íŠ¹ë³„ì‹œ", clue: "ëŒ€í•œë¯¼êµ­ ìˆ˜ë„ì˜ ì •ì‹ ëª…ì¹­", difficulty: "expert"},
            {word: "í•œê¸€ì°½ì œì¼", clue: "ì„¸ì¢…ëŒ€ì™•ì´ í•œê¸€ì„ ë§Œë“  ë‚ ", difficulty: "expert"},
            {word: "êµ­ë¯¼ê±´ê°•ë³´í—˜", clue: "ì˜ë£Œ ë³´í—˜ ì œë„", difficulty: "expert"},
            {word: "ì¸í„°ë„·ì‡¼í•‘ëª°", clue: "ì˜¨ë¼ì¸ ì‡¼í•‘ ì‚¬ì´íŠ¸", difficulty: "expert"}
        ];

        // APIì—ì„œ ê°€ì ¸ì˜¨ ì¶”ê°€ ë‹¨ì–´ë“¤ì„ ì €ì¥
        let apiWords = [];
        let currentDifficulty = 'medium';

        class AdvancedKoreanCrossword {
            constructor(size = 15, difficulty = 'medium') {
                this.size = this.getSizeByDifficulty(difficulty);
                this.difficulty = difficulty;
                this.grid = [];
                this.solution = [];
                this.numbers = [];
                this.acrossWords = [];
                this.downWords = [];
                this.cellNumbers = {};
                this.usedWords = new Set();
                this.intersections = 0;
                this.selectedWord = null;
            }

            getSizeByDifficulty(difficulty) {
                // í™”ë©´ í¬ê¸°ì— ë”°ë¼ ê·¸ë¦¬ë“œ í¬ê¸° ì¡°ì •
                const screenWidth = window.innerWidth;
                let baseSize = {
                    'easy': 12,
                    'medium': 15,
                    'hard': 20,
                    'expert': 25
                }[difficulty];

                // ëª¨ë°”ì¼ì—ì„œëŠ” ê·¸ë¦¬ë“œ í¬ê¸° ì¶•ì†Œ
                if (screenWidth < 768) {
                    baseSize = Math.min(baseSize, 15);
                }
                if (screenWidth < 480) {
                    baseSize = Math.min(baseSize, 12);
                }

                return baseSize;
            }

            getWordsByDifficulty() {
                const allWords = [...wordDatabase, ...apiWords];
                return allWords.filter(w => {
                    if (this.difficulty === 'easy') return w.word.length >= 2 && w.word.length <= 3;
                    if (this.difficulty === 'medium') return w.word.length >= 2 && w.word.length <= 4;
                    if (this.difficulty === 'hard') return w.word.length >= 2 && w.word.length <= 5; // ì–´ë ¤ì›€: 2-5ê¸€ì ëª¨ë‘ ì‚¬ìš©
                    if (this.difficulty === 'expert') return w.word.length >= 2 && w.word.length <= 5; // ì „ë¬¸ê°€: 2-5ê¸€ì ëª¨ë‘ ì‚¬ìš©
                    return true;
                });
            }

            generate() {
                this.initGrid();
                this.placeWords();
                this.numberCells();
                this.fillBlackCells();
            }

            initGrid() {
                this.grid = Array(this.size).fill().map(() =>
                    Array(this.size).fill(null)
                );
                this.solution = Array(this.size).fill().map(() =>
                    Array(this.size).fill('')
                );
            }

            placeWords() {
                let availableWords = this.getWordsByDifficulty();

                // ì–´ë ¤ì›€ê³¼ ì „ë¬¸ê°€ ëª¨ë“œì—ì„œëŠ” ì—¬ëŸ¬ ì‹œì‘ì  ì‚¬ìš©
                if (this.difficulty === 'hard' || this.difficulty === 'expert') {
                    this.placeMultipleStartingWords(availableWords);
                } else {
                    // ì²« ë‹¨ì–´ëŠ” ì¤‘ì•™ì— ê°€ë¡œë¡œ ë°°ì¹˜
                    const centerRow = Math.floor(this.size / 2);
                    const firstWord = this.selectWord(availableWords,
                        this.difficulty === 'easy' ? 2 : 3,
                        this.difficulty === 'medium' ? 4 : 5
                    );
                    const startCol = Math.floor((this.size - firstWord.word.length) / 2);

                    this.placeWord(firstWord, centerRow, startCol, 'across');
                    availableWords = availableWords.filter(w => w.word !== firstWord.word);
                }

                // ëª©í‘œ ë‹¨ì–´ ìˆ˜ëŠ” ë‚œì´ë„ì— ë”°ë¼ (ì „ë¬¸ê°€ëŠ” í˜„ì‹¤ì ìœ¼ë¡œ ì¡°ì •)
                const targetWords = {
                    'easy': 15,
                    'medium': 25,
                    'hard': 30,
                    'expert': 40
                }[this.difficulty];

                let attempts = 0;
                const maxAttempts = 2000;

                // ì–´ë ¤ì›€/ì „ë¬¸ê°€ ëª¨ë“œì˜ ê²½ìš° ì €ì¥ëœ availableWords ì‚¬ìš©
                if ((this.difficulty === 'hard' || this.difficulty === 'expert') && this.availableWords) {
                    availableWords = this.availableWords;
                }

                while (this.acrossWords.length + this.downWords.length < targetWords && attempts < maxAttempts) {
                    attempts++;
                    const intersections = this.findPossibleIntersections(availableWords);

                    if (intersections.length === 0) {
                        // ì–´ë ¤ì›€/ì „ë¬¸ê°€ ëª¨ë“œ: ë¹ˆ ê³µê°„ì— ìƒˆë¡œìš´ ë‹¨ì–´ ê·¸ë£¹ ì‹œì‘
                        if ((this.difficulty === 'hard' || this.difficulty === 'expert') && attempts % 100 === 0) {
                            const randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
                            if (randomWord && this.tryForcePlace(randomWord)) {
                                availableWords = availableWords.filter(w => w.word !== randomWord.word);
                            }
                        }
                        continue;
                    }

                    // ì–´ë ¤ì›€/ì „ë¬¸ê°€ ëª¨ë“œì—ì„œëŠ” ë‹¤ì–‘í•œ ìœ„ì¹˜ ì„ íƒ
                    if ((this.difficulty === 'hard' || this.difficulty === 'expert') && intersections.length > 5) {
                        // ìƒìœ„ 5ê°œ ì¤‘ì—ì„œ ëœë¤ ì„ íƒ
                        intersections.sort((a, b) => b.score - a.score);
                        const topChoices = intersections.slice(0, 5);
                        const best = topChoices[Math.floor(Math.random() * topChoices.length)];
                        this.placeWord(best.word, best.row, best.col, best.direction);
                        availableWords = availableWords.filter(w => w.word !== best.word.word);
                    } else {
                        intersections.sort((a, b) => b.score - a.score);
                        const best = intersections[0];
                        this.placeWord(best.word, best.row, best.col, best.direction);
                        availableWords = availableWords.filter(w => w.word !== best.word.word);
                    }
                }
            }

            selectWord(words, minLen, maxLen) {
                const filtered = words.filter(w =>
                    w.word.length >= minLen && w.word.length <= maxLen
                );
                return filtered[Math.floor(Math.random() * filtered.length)] || words[0];
            }

            findPossibleIntersections(availableWords) {
                const intersections = [];
                const existingWords = [...this.acrossWords, ...this.downWords];

                for (const existing of existingWords) {
                    for (let i = 0; i < existing.word.word.length; i++) {
                        const letter = existing.word.word[i];

                        for (const candidate of availableWords) {
                            const letterPos = candidate.word.indexOf(letter);
                            if (letterPos === -1) continue;

                            const newDir = existing.direction === 'across' ? 'down' : 'across';

                            let newRow, newCol;
                            if (existing.direction === 'across') {
                                newRow = existing.row - letterPos;
                                newCol = existing.col + i;
                            } else {
                                newRow = existing.row + i;
                                newCol = existing.col - letterPos;
                            }

                            if (this.canPlaceWord(candidate.word, newRow, newCol, newDir)) {
                                const score = this.calculatePlacementScore(candidate.word, newRow, newCol, newDir);
                                if (score > 0) {
                                    intersections.push({
                                        word: candidate,
                                        row: newRow,
                                        col: newCol,
                                        direction: newDir,
                                        score: score
                                    });
                                }
                            }
                        }
                    }
                }

                return intersections;
            }

            canPlaceWord(word, row, col, direction) {
                if (row < 0 || col < 0) return false;
                if (direction === 'across' && col + word.length > this.size) return false;
                if (direction === 'down' && row + word.length > this.size) return false;

                let hasIntersection = false;

                for (let i = 0; i < word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (this.solution[r][c]) {
                        if (this.solution[r][c] !== word[i]) {
                            return false;
                        }
                        hasIntersection = true;
                    }

                    if (direction === 'across') {
                        if (r > 0 && this.solution[r-1][c] && !this.solution[r][c]) return false;
                        if (r < this.size-1 && this.solution[r+1][c] && !this.solution[r][c]) return false;
                    } else {
                        if (c > 0 && this.solution[r][c-1] && !this.solution[r][c]) return false;
                        if (c < this.size-1 && this.solution[r][c+1] && !this.solution[r][c]) return false;
                    }
                }

                if (direction === 'across') {
                    if (col > 0 && this.solution[row][col-1]) return false;
                    if (col + word.length < this.size && this.solution[row][col + word.length]) return false;
                } else {
                    if (row > 0 && this.solution[row-1][col]) return false;
                    if (row + word.length < this.size && this.solution[row + word.length][col]) return false;
                }

                // ì „ë¬¸ê°€ ëª¨ë“œì—ì„œëŠ” êµì°¨ì  ìš”êµ¬ì‚¬í•­ ì™„í™”
                if (this.difficulty === 'expert' && this.acrossWords.length + this.downWords.length > 30) {
                    return true;
                }

                return true;
            }

            calculatePlacementScore(word, row, col, direction) {
                let score = 0;
                let intersections = 0;

                for (let i = 0; i < word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (this.solution[r][c]) {
                        intersections++;
                        score += 10;
                    }
                }

                if (intersections === 0) return -1;

                const lastR = direction === 'across' ? row : row + word.length - 1;
                const lastC = direction === 'across' ? col + word.length - 1 : col;
                const centerDist = Math.abs(lastR - this.size/2) + Math.abs(lastC - this.size/2);
                score += (this.size - centerDist);
                score += word.length * 2;

                return score;
            }

            placeWord(wordObj, row, col, direction) {
                for (let i = 0; i < wordObj.word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (this.solution[r][c] && this.solution[r][c] === wordObj.word[i]) {
                        this.intersections++;
                    }

                    this.solution[r][c] = wordObj.word[i];
                    this.grid[r][c] = 'letter';
                }

                const wordInfo = {
                    word: wordObj,
                    row: row,
                    col: col,
                    direction: direction,
                    number: 0
                };

                if (direction === 'across') {
                    this.acrossWords.push(wordInfo);
                } else {
                    this.downWords.push(wordInfo);
                }

                this.usedWords.add(wordObj.word);
            }

            numberCells() {
                let number = 1;
                this.numbers = Array(this.size).fill().map(() =>
                    Array(this.size).fill(0)
                );

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] !== 'letter') continue;

                        let needsNumber = false;

                        if ((c === 0 || this.grid[r][c-1] !== 'letter') &&
                            c < this.size - 1 && this.grid[r][c+1] === 'letter') {
                            needsNumber = true;
                            for (const word of this.acrossWords) {
                                if (word.row === r && word.col === c) {
                                    word.number = number;
                                    break;
                                }
                            }
                        }

                        if ((r === 0 || this.grid[r-1][c] !== 'letter') &&
                            r < this.size - 1 && this.grid[r+1][c] === 'letter') {
                            needsNumber = true;
                            for (const word of this.downWords) {
                                if (word.row === r && word.col === c) {
                                    word.number = number;
                                    break;
                                }
                            }
                        }

                        if (needsNumber) {
                            this.numbers[r][c] = number;
                            this.cellNumbers[`${r},${c}`] = number;
                            number++;
                        }
                    }
                }
            }

            placeMultipleStartingWords(availableWords) {
                // ê·¸ë¦¬ë“œë¥¼ êµ¬ì—­ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ê° êµ¬ì—­ì— ì‹œì‘ ë‹¨ì–´ ë°°ì¹˜
                const zones = this.difficulty === 'hard' ?
                    // ì–´ë ¤ì›€ ëª¨ë“œ: 4ê°œ êµ¬ì—­
                    [
                        {row: Math.floor(this.size * 0.25), col: Math.floor(this.size * 0.25)}, // ìƒë‹¨ ì¢Œì¸¡
                        {row: Math.floor(this.size * 0.25), col: Math.floor(this.size * 0.65)}, // ìƒë‹¨ ìš°ì¸¡
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.5)}, // ì¤‘ì•™
                        {row: Math.floor(this.size * 0.7), col: Math.floor(this.size * 0.35)}, // í•˜ë‹¨
                    ] :
                    // ì „ë¬¸ê°€ ëª¨ë“œ: 5ê°œ êµ¬ì—­
                    [
                        {row: Math.floor(this.size * 0.2), col: Math.floor(this.size * 0.3)}, // ìƒë‹¨
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.2)}, // ì¤‘ì•™ ì¢Œì¸¡
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.5)}, // ì¤‘ì•™
                        {row: Math.floor(this.size * 0.5), col: Math.floor(this.size * 0.7)}, // ì¤‘ì•™ ìš°ì¸¡
                        {row: Math.floor(this.size * 0.7), col: Math.floor(this.size * 0.4)}, // í•˜ë‹¨
                    ];

                const maxZones = this.difficulty === 'hard' ? 4 : 5;
                for (let i = 0; i < zones.length && i < maxZones; i++) {
                    const zone = zones[i];
                    const word = this.selectWord(availableWords, 3, 5);
                    if (word) {
                        const direction = i % 2 === 0 ? 'across' : 'down';

                        // êµ¬ì—­ ë‚´ì—ì„œ ì•½ê°„ì˜ ëœë¤ ìœ„ì¹˜ ì¡°ì •
                        const randomOffset = Math.floor(Math.random() * 3) - 1;
                        const adjustedRow = Math.max(0, Math.min(this.size - 5, zone.row + randomOffset));
                        const adjustedCol = Math.max(0, Math.min(this.size - 5, zone.col + randomOffset));

                        if (this.canPlaceWord(word.word, adjustedRow, adjustedCol, direction)) {
                            this.placeWord(word, adjustedRow, adjustedCol, direction);
                            availableWords = availableWords.filter(w => w.word !== word.word);
                        }
                    }
                }

                // ë‚˜ë¨¸ì§€ ë‹¨ì–´ë“¤ì„ availableWordsì— ìœ ì§€
                this.availableWords = availableWords;
            }

            tryForcePlace(wordObj) {
                // ì „ë¬¸ê°€ ëª¨ë“œì—ì„œ ë¹ˆ ê³µê°„ ì°¾ì•„ì„œ ë°°ì¹˜
                const emptySpots = [];

                // ë¹ˆ ê³µê°„ ìˆ˜ì§‘
                for (let r = 1; r < this.size - 1; r += 3) {
                    for (let c = 1; c < this.size - 1; c += 3) {
                        let isEmpty = true;
                        for (let dr = -1; dr <= 1 && isEmpty; dr++) {
                            for (let dc = -1; dc <= 1 && isEmpty; dc++) {
                                if (this.grid[r + dr] && this.grid[r + dr][c + dc]) {
                                    isEmpty = false;
                                }
                            }
                        }
                        if (isEmpty) {
                            emptySpots.push({row: r, col: c});
                        }
                    }
                }

                // ëœë¤í•œ ë¹ˆ ê³µê°„ì— ë°°ì¹˜ ì‹œë„
                const shuffled = emptySpots.sort(() => Math.random() - 0.5);

                for (const spot of shuffled) {
                    // ê°€ë¡œ ì‹œë„
                    if (spot.col + wordObj.word.length <= this.size) {
                        if (this.canPlaceWordLoose(wordObj.word, spot.row, spot.col, 'across')) {
                            this.placeWord(wordObj, spot.row, spot.col, 'across');
                            return true;
                        }
                    }

                    // ì„¸ë¡œ ì‹œë„
                    if (spot.row + wordObj.word.length <= this.size) {
                        if (this.canPlaceWordLoose(wordObj.word, spot.row, spot.col, 'down')) {
                            this.placeWord(wordObj, spot.row, spot.col, 'down');
                            return true;
                        }
                    }
                }
                return false;
            }

            canPlaceWordLoose(word, row, col, direction) {
                // ë” ëŠìŠ¨í•œ ë°°ì¹˜ ê·œì¹™ (ì „ë¬¸ê°€ ëª¨ë“œìš©)
                for (let i = 0; i < word.length; i++) {
                    const r = direction === 'across' ? row : row + i;
                    const c = direction === 'across' ? col + i : col;

                    if (r < 0 || r >= this.size || c < 0 || c >= this.size) {
                        return false;
                    }

                    if (this.solution[r][c] && this.solution[r][c] !== word[i]) {
                        return false;
                    }
                }
                return true;
            }

            fillBlackCells() {
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] === null) {
                            this.grid[r][c] = 'black';
                        }
                    }
                }
            }

            display() {
                const gridElement = document.getElementById('crosswordGrid');
                gridElement.innerHTML = '';
                gridElement.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        if (this.grid[r][c] === 'black') {
                            cell.className += ' black';
                        } else if (this.grid[r][c] === 'letter') {
                            cell.className += ' filled';

                            if (this.numbers[r][c] > 0) {
                                const number = document.createElement('div');
                                number.className = 'number';
                                number.textContent = this.numbers[r][c];
                                cell.appendChild(number);
                            }

                            const letterDisplay = document.createElement('div');
                            letterDisplay.className = 'letter-display';
                            letterDisplay.dataset.solution = this.solution[r][c];
                            letterDisplay.dataset.row = r;
                            letterDisplay.dataset.col = c;
                            letterDisplay.textContent = ''; // ë¹ˆ ìƒíƒœë¡œ ì‹œì‘

                            // í´ë¦­ì‹œ í•´ë‹¹ ë‹¨ì–´ ì„ íƒ ë° ì…ë ¥ì°½ ì—´ê¸°
                            cell.addEventListener('click', () => this.handleCellClick(r, c));

                            cell.appendChild(letterDisplay);
                        }

                        gridElement.appendChild(cell);
                    }
                }

                this.displayClues();
                this.updateStats();
            }

            handleCellClick(row, col) {
                // í´ë¦­í•œ ì…€ì´ ì†í•œ ë‹¨ì–´ ì°¾ê¸°
                let wordFound = null;

                // ê°€ë¡œ ë‹¨ì–´ í™•ì¸
                for (const word of this.acrossWords) {
                    if (row === word.row &&
                        col >= word.col &&
                        col < word.col + word.word.word.length) {
                        wordFound = word;
                        break;
                    }
                }

                // ì„¸ë¡œ ë‹¨ì–´ í™•ì¸
                if (!wordFound) {
                    for (const word of this.downWords) {
                        if (col === word.col &&
                            row >= word.row &&
                            row < word.row + word.word.word.length) {
                            wordFound = word;
                            break;
                        }
                    }
                }

                if (wordFound) {
                    this.highlightWord(wordFound);
                    this.openAnswerInput(wordFound);
                }
            }

            openAnswerInput(word) {
                this.currentInputWord = word;

                const container = document.getElementById('answerInputContainer');
                const title = document.getElementById('inputTitle');
                const clue = document.getElementById('inputClue');
                const input = document.getElementById('answerInput');

                title.textContent = `${word.number}ë²ˆ ${word.direction === 'across' ? 'ê°€ë¡œ' : 'ì„¸ë¡œ'} (${word.word.word.length}ê¸€ì)`;
                clue.textContent = word.word.clue;
                input.value = this.getCurrentAnswer(word);
                input.maxLength = word.word.word.length;

                container.classList.add('active');
                input.focus();
                input.select();

                // ì—”í„°í‚¤ë¡œ ì œì¶œ
                input.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        submitAnswer();
                    }
                };
            }

            getCurrentAnswer(word) {
                let answer = '';
                for (let i = 0; i < word.word.word.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"] .letter-display`);
                    if (cell && cell.textContent) {
                        answer += cell.textContent;
                    }
                }
                return answer;
            }

            setWordAnswer(word, answer) {
                for (let i = 0; i < word.word.word.length && i < answer.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"] .letter-display`);
                    if (cell) {
                        cell.textContent = answer[i];
                    }
                }
            }

            displayClues() {
                const acrossClues = document.getElementById('acrossClues');
                acrossClues.innerHTML = '';

                this.acrossWords.sort((a, b) => a.number - b.number);
                for (const word of this.acrossWords) {
                    if (word.number === 0) continue;
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="clue-number">${word.number}.</span> ${word.word.clue}`;
                    li.dataset.number = word.number;
                    li.dataset.direction = 'across';
                    li.onclick = () => this.highlightWord(word);
                    acrossClues.appendChild(li);
                }

                const downClues = document.getElementById('downClues');
                downClues.innerHTML = '';

                this.downWords.sort((a, b) => a.number - b.number);
                for (const word of this.downWords) {
                    if (word.number === 0) continue;
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="clue-number">${word.number}.</span> ${word.word.clue}`;
                    li.dataset.number = word.number;
                    li.dataset.direction = 'down';
                    li.onclick = () => this.highlightWord(word);
                    downClues.appendChild(li);
                }
            }

            highlightWord(word) {
                // ëª¨ë“  ì„ íƒ ì œê±°
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selected');
                });
                document.querySelectorAll('.clue-list li').forEach(li => {
                    li.classList.remove('selected');
                });

                // í˜„ì¬ ë‹¨ì–´ ì„ íƒ
                this.selectedWord = word;

                // ë‹¨ì–´ ì¹¸ë“¤ í•˜ì´ë¼ì´íŠ¸
                for (let i = 0; i < word.word.word.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('selected');
                    }
                }

                // í˜„ì¬ ì¹¸ í‘œì‹œ
                for (let i = 0; i < word.word.word.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('current');
                    }
                }

                // íŒíŠ¸ í•˜ì´ë¼ì´íŠ¸
                const selector = `[data-number="${word.number}"][data-direction="${word.direction}"]`;
                const clueElement = document.querySelector(selector);
                if (clueElement) {
                    clueElement.classList.add('selected');
                    clueElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            updateStats() {
                document.getElementById('wordCount').textContent =
                    this.acrossWords.length + this.downWords.length;
                document.getElementById('intersectionCount').textContent = this.intersections;
                document.getElementById('gridSize').textContent = `${this.size}x${this.size}`;

                const difficultyText = {
                    'easy': 'ì‰¬ì›€',
                    'medium': 'ë³´í†µ',
                    'hard': 'ì–´ë ¤ì›€',
                    'expert': 'ì „ë¬¸ê°€'
                }[this.difficulty];
                document.getElementById('difficultyLevel').textContent = difficultyText;
            }
        }

        let crossword;

        function generateNewPuzzle() {
            const difficulty = document.getElementById('difficulty').value;
            crossword = new AdvancedKoreanCrossword(15, difficulty);
            crossword.generate();
            crossword.display();
        }

        function changeDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            generateNewPuzzle();
        }

        function submitAnswer() {
            const input = document.getElementById('answerInput');
            const answer = input.value.trim();

            if (answer && crossword.currentInputWord) {
                crossword.setWordAnswer(crossword.currentInputWord, answer);
            }

            cancelInput();
        }

        function cancelInput() {
            const container = document.getElementById('answerInputContainer');
            container.classList.remove('active');

            // current í´ë˜ìŠ¤ ì œê±°
            document.querySelectorAll('.cell.current').forEach(cell => {
                cell.classList.remove('current');
            });
        }

        function clearCurrentWord() {
            if (crossword.currentInputWord) {
                crossword.setWordAnswer(crossword.currentInputWord, '');
                document.getElementById('answerInput').value = '';
            }
        }

        function showSolution() {
            const cells = document.querySelectorAll('.cell .letter-display');
            cells.forEach(cell => {
                if (cell.dataset.solution) {
                    cell.textContent = cell.dataset.solution;
                    cell.style.color = 'blue';
                }
            });
        }

        function checkAnswers() {
            const cells = document.querySelectorAll('.cell .letter-display');
            let correct = 0;
            let total = 0;

            cells.forEach(cell => {
                if (cell.dataset.solution) {
                    total++;
                    cell.parentElement.classList.remove('correct', 'incorrect');
                    if (cell.textContent === cell.dataset.solution) {
                        cell.parentElement.classList.add('correct');
                        correct++;
                    } else if (cell.textContent) {
                        cell.parentElement.classList.add('incorrect');
                    }
                }
            });

            setTimeout(() => {
                alert(`ì •ë‹µ: ${correct}/${total} (${Math.round(correct/total*100)}%)`);
            }, 100);
        }

        function getHint() {
            const cells = document.querySelectorAll('.cell .letter-display');
            const emptyCells = Array.from(cells).filter(cell =>
                cell.dataset.solution && !cell.textContent
            );

            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                randomCell.textContent = randomCell.dataset.solution;
                randomCell.style.color = 'green';
            } else {
                alert('ëª¨ë“  ì¹¸ì´ ì±„ì›Œì ¸ ìˆìŠµë‹ˆë‹¤!');
            }
        }

        function clearInputs() {
            const cells = document.querySelectorAll('.cell .letter-display');
            cells.forEach(cell => {
                cell.textContent = '';
                cell.style.color = '';
                cell.parentElement.classList.remove('correct', 'incorrect');
            });

            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('selected', 'current');
            });
            document.querySelectorAll('.clue-list li').forEach(li => {
                li.classList.remove('selected');
            });

            cancelInput();
        }

        async function loadFromAPI() {
            const loading = document.getElementById('loading');
            loading.classList.add('active');

            try {
                // API í‚¤ê°€ ì—†ìœ¼ë©´ ë¡œì»¬ ë‹¨ì–´ ì¶”ê°€
                const apiKey = 'YOUR_API_KEY_HERE'; // í™˜ê²½ë³€ìˆ˜ë‚˜ ì„œë²„ì—ì„œ ê´€ë¦¬

                if (apiKey === 'YOUR_API_KEY_HERE') {
                    // API í‚¤ ì—†ì„ ë•Œ ëŒ€ì²´ ë‹¨ì–´ ì¶”ê°€
                    addFallbackWords();
                    loading.classList.remove('active');
                    alert('ìƒ˜í”Œ ë‹¨ì–´ 50ê°œë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤!');
                    generateNewPuzzle();
                    return;
                }
                const searchWords = ['í•™êµ', 'ì»´í“¨í„°', 'ì¸í„°ë„·', 'í•œêµ­', 'ì„œìš¸', 'ìŒì•…', 'ì˜í™”', 'ìš´ë™', 'ì‚¬ë‘', 'ì¹œêµ¬', 'ê°€ì¡±', 'ìŒì‹'];

                for (const searchWord of searchWords) {
                    try {
                        // êµ­ë¦½êµ­ì–´ì› API í˜¸ì¶œ
                        const response = await fetch(`https://krdict.korean.go.kr/api/search?key=${apiKey}&q=${searchWord}&num=20&advanced=y&method=exact&type1=word&type3=general`);

                        if (response.ok) {
                            const data = await response.text();
                            // XML íŒŒì‹±
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(data, "text/xml");
                            const items = xmlDoc.getElementsByTagName('item');

                            for (let i = 0; i < Math.min(items.length, 10); i++) {
                                const wordElement = items[i].getElementsByTagName('word')[0];
                                const senseElement = items[i].getElementsByTagName('sense')[0];

                                if (wordElement && senseElement) {
                                    const word = wordElement.textContent.replace(/-/g, '').replace(/\^/g, '');
                                    const definition = senseElement.getElementsByTagName('definition')[0];

                                    if (word && definition && word.length >= 2 && word.length <= 8) {
                                        const clue = definition.textContent.split('.')[0].substring(0, 30);

                                        // ë‚œì´ë„ ìë™ ì„¤ì •
                                        let difficulty = 'easy';
                                        if (word.length >= 6) difficulty = 'expert';
                                        else if (word.length >= 5) difficulty = 'hard';
                                        else if (word.length >= 4) difficulty = 'medium';

                                        const newWord = {
                                            word: word,
                                            clue: clue || `${searchWord} ê´€ë ¨ ë‹¨ì–´`,
                                            difficulty: difficulty
                                        };

                                        // ì¤‘ë³µ í™•ì¸ í›„ ì¶”ê°€
                                        if (!wordDatabase.some(w => w.word === newWord.word) &&
                                            !apiWords.some(w => w.word === newWord.word)) {
                                            apiWords.push(newWord);
                                        }
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.log(`Failed to fetch ${searchWord}:`, err);
                    }

                    // ë°±ì—…ìš© ìƒ˜í”Œ ë°ì´í„°
                    const sampleWords = [
                        {word: "í•™êµìƒí™œ", clue: "í•™ìƒë“¤ì˜ ì¼ìƒ", difficulty: "hard"},
                        {word: "ì»´í“¨í„°ì‹¤", clue: "PCê°€ ìˆëŠ” êµì‹¤", difficulty: "hard"},
                        {word: "ì¸í„°ë„·ë§", clue: "ì˜¨ë¼ì¸ ë„¤íŠ¸ì›Œí¬", difficulty: "hard"},
                        {word: "í•œêµ­ë¬¸í™”", clue: "ìš°ë¦¬ë‚˜ë¼ì˜ ì „í†µê³¼ í˜„ëŒ€", difficulty: "hard"},
                        {word: "ì„œìš¸ì—­", clue: "ìˆ˜ë„ì˜ ì¤‘ì•™ ê¸°ì°¨ì—­", difficulty: "medium"},
                        {word: "ìŒì•…íšŒ", clue: "ì—°ì£¼ë¥¼ ë“£ëŠ” í–‰ì‚¬", difficulty: "medium"},
                        {word: "ì˜í™”ê´€", clue: "ì˜í™”ë¥¼ ë³´ëŠ” ê³³", difficulty: "medium"},
                        {word: "ìš´ë™ì¥", clue: "ì²´ìœ¡ í™œë™ì„ í•˜ëŠ” ê³³", difficulty: "medium"},
                        {word: "ë„ì„œê´€", clue: "ì±…ì„ ë¹Œë¦¬ëŠ” ê³³", difficulty: "medium"},
                        {word: "ë³‘ì›", clue: "ì•„í”ˆ ì‚¬ëŒì„ ì¹˜ë£Œí•˜ëŠ” ê³³", difficulty: "easy"},
                        {word: "ì€í–‰", clue: "ëˆì„ ë§¡ê¸°ëŠ” ê³³", difficulty: "easy"},
                        {word: "ìš°ì²´êµ­", clue: "í¸ì§€ë¥¼ ë³´ë‚´ëŠ” ê³³", difficulty: "medium"},
                        {word: "ê²½ì°°ì„œ", clue: "ì¹˜ì•ˆì„ ë‹´ë‹¹í•˜ëŠ” ê³³", difficulty: "medium"},
                        {word: "ì†Œë°©ì„œ", clue: "í™”ì¬ë¥¼ ì§„ì••í•˜ëŠ” ê³³", difficulty: "medium"},
                        {word: "ëŒ€í•™êµ", clue: "ê³ ë“±êµìœ¡ ê¸°ê´€", difficulty: "medium"},
                        {word: "ì´ˆë“±í•™êµ", clue: "ì–´ë¦°ì´ë“¤ì´ ë‹¤ë‹ˆëŠ” í•™êµ", difficulty: "hard"},
                        {word: "ì¤‘í•™êµ", clue: "ì´ˆë“±í•™êµ ë‹¤ìŒ ê³¼ì •", difficulty: "medium"},
                        {word: "ê³ ë“±í•™êµ", clue: "ëŒ€í•™ ì „ êµìœ¡ê³¼ì •", difficulty: "hard"},
                        {word: "ìœ ì¹˜ì›", clue: "ë¯¸ì·¨í•™ ì•„ë™ êµìœ¡ê¸°ê´€", difficulty: "medium"},
                        {word: "ë†€ì´í„°", clue: "ì•„ì´ë“¤ì´ ë…¸ëŠ” ê³³", difficulty: "medium"}
                    ];

                    // ì¤‘ë³µ ì œê±° í›„ ì¶”ê°€
                    sampleWords.forEach(newWord => {
                        if (!wordDatabase.some(w => w.word === newWord.word) &&
                            !apiWords.some(w => w.word === newWord.word)) {
                            apiWords.push(newWord);
                        }
                    });
                }

                loading.classList.remove('active');
                alert(`${apiWords.length}ê°œì˜ ìƒˆë¡œìš´ ë‹¨ì–´ë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤!`);
                generateNewPuzzle();

            } catch (error) {
                console.error('API ë¡œë“œ ì‹¤íŒ¨:', error);
                loading.classList.remove('active');
                alert('ë‹¨ì–´ ë¶ˆëŸ¬ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìƒ˜í”Œ ë‹¨ì–´ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.');

                // ì˜¤ë¥˜ì‹œì—ë„ ìƒ˜í”Œ ë‹¨ì–´ ì¶”ê°€
                const fallbackWords = [
                    {word: "ë´„ë‚ ", clue: "ë”°ëœ»í•œ ê³„ì ˆì˜ í•˜ë£¨", difficulty: "easy"},
                    {word: "ì—¬ë¦„ë°¤", clue: "ë”ìš´ ê³„ì ˆì˜ ì €ë…", difficulty: "medium"},
                    {word: "ê°€ì„ë¹„", clue: "ë‹¨í’ ê³„ì ˆì˜ ê°•ìˆ˜", difficulty: "medium"},
                    {word: "ê²¨ìš¸ì ", clue: "ë™ë¬¼ì˜ ë™ë©´", difficulty: "medium"}
                ];
                fallbackWords.forEach(word => {
                    if (!wordDatabase.some(w => w.word === word.word)) {
                        apiWords.push(word);
                    }
                });
                generateNewPuzzle();
            }
        }

        // ê°œë°œì ì½˜ì†” ë©”ì‹œì§€
        console.log('%cğŸŒ² ë‹¨ì–´ì˜ ìˆ² - Word Forest ğŸŒ²', 'background: linear-gradient(135deg, #134e4a, #14b8a6); color: white; font-size: 20px; padding: 10px; border-radius: 5px; font-weight: bold;');
        console.log('%cCreated by SunnyBear', 'color: #14b8a6; font-size: 16px; font-weight: bold;');
        console.log('%cğŸ“ Blog: https://wonusdwant.tistory.com', 'color: #134e4a; font-size: 14px;');
        console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #14b8a6;');
        console.log('%cğŸ’¡ Features:', 'color: #14b8a6; font-size: 14px; font-weight: bold;');
        console.log('%câ€¢ Multi-cluster crossword generation', 'color: #333; font-size: 12px;');
        console.log('%câ€¢ Korean language optimized input system', 'color: #333; font-size: 12px;');
        console.log('%câ€¢ Dynamic difficulty adjustment', 'color: #333; font-size: 12px;');
        console.log('%câ€¢ National Korean Dictionary API integration', 'color: #333; font-size: 12px;');
        console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #14b8a6;');
        console.log('%cÂ© 2025 SunnyBear. All rights reserved.', 'color: #999; font-size: 12px;');
        console.log('%cDeveloped with â¤ï¸ at wonusdwant.tistory.com', 'color: #999; font-size: 12px;');

        // ASCII ì•„íŠ¸ ì¶”ê°€
        console.log(`%c
    Ê•â€¢á´¥â€¢Ê”
   SunnyBear
  `, 'color: #14b8a6; font-family: monospace;');

        // API ì—†ì„ ë•Œ ëŒ€ì²´ ë‹¨ì–´ í•¨ìˆ˜
        function addFallbackWords() {
            const extraWords = [
                {word: "í•™êµ", clue: "í•™ìƒë“¤ì´ ê³µë¶€í•˜ëŠ” ê³³", difficulty: "easy"},
                {word: "ì¹œêµ¬", clue: "í•¨ê»˜ ë…¸ëŠ” ì‚¬ëŒ", difficulty: "easy"},
                {word: "ê°€ì¡±", clue: "ì—„ë§ˆ ì•„ë¹ ì™€ í•¨ê»˜", difficulty: "easy"},
                {word: "ì„ ìƒ", clue: "ê°€ë¥´ì¹˜ëŠ” ë¶„", difficulty: "easy"},
                {word: "ì»´í“¨", clue: "___í„°, PC", difficulty: "easy"},
                {word: "íœ´ëŒ€", clue: "___í°", difficulty: "easy"},
                {word: "ìì „", clue: "___ê±°, í˜ë‹¬", difficulty: "easy"},
                {word: "ë†€ì´", clue: "___ê³µì›", difficulty: "easy"},
                {word: "ìƒì¼", clue: "ì¼€ì´í¬ ë¨¹ëŠ” ë‚ ", difficulty: "easy"},
                {word: "ê¹€ì¹˜", clue: "í•œêµ­ ë°œíš¨ ìŒì‹", difficulty: "easy"},
                {word: "í•œë³µ", clue: "ì „í†µ ì˜ìƒ", difficulty: "easy"},
                {word: "ë¶ˆê³ ", clue: "___ê¸°, ë‹¬ì½¤í•œ ê³ ê¸°", difficulty: "easy"},
                {word: "ë–¡ë³¶", clue: "___ì´, ë§¤ìš´ ë–¡", difficulty: "easy"},
                {word: "ë¹„ë¹”", clue: "___ë°¥", difficulty: "easy"},
                {word: "ì‚¼ê²¹", clue: "___ì‚´", difficulty: "easy"},
                {word: "ì¡ì±„", clue: "ë‹¹ë©´ ìš”ë¦¬", difficulty: "easy"},
                {word: "ê°ˆë¹„", clue: "ì†Œê°ˆë¹„ êµ¬ì´", difficulty: "easy"},
                {word: "ëƒ‰ë©´", clue: "ì°¨ê°€ìš´ êµ­ìˆ˜", difficulty: "easy"},
                {word: "íŒŒì „", clue: "íŒŒë¡œ ë§Œë“  ì „", difficulty: "easy"},
                {word: "í˜¸ë–¡", clue: "ë‹¬ì½¤í•œ ê°„ì‹", difficulty: "easy"},
                {word: "ë¶•ì–´", clue: "___ë¹µ", difficulty: "easy"},
                {word: "ê³„ë€", clue: "ë‹¬ê±€", difficulty: "easy"},
                {word: "ë¯¸ì—­", clue: "ìƒì¼ë‚  êµ­", difficulty: "easy"},
                {word: "ê°ì", clue: "___íƒ•", difficulty: "easy"},
                {word: "ìˆœëŒ€", clue: "ë¼ì§€ ì°½ì ìš”ë¦¬", difficulty: "easy"},
                {word: "ê³°íƒ•", clue: "ì†Œë¼ˆ êµ­ë¬¼", difficulty: "easy"},
                {word: "ì˜¤ì§•", clue: "___ì–´, ë‹¤ë¦¬ 10ê°œ", difficulty: "easy"},
                {word: "ê³ ë“±", clue: "___ì–´, ë“±í‘¸ë¥¸ ìƒì„ ", difficulty: "easy"},
                {word: "ê°ˆì¹˜", clue: "ê¸´ ì€ìƒ‰ ìƒì„ ", difficulty: "easy"},
                {word: "ì—°ì–´", clue: "ì£¼í™©ìƒ‰ ìƒì„ ", difficulty: "easy"},
                {word: "ê´‘ì–´", clue: "ë‚©ì‘í•œ ìƒì„ ", difficulty: "easy"},
                {word: "ìš°ëŸ­", clue: "ë§¤ìš´íƒ• ìƒì„ ", difficulty: "easy"},
                {word: "ë†ì–´", clue: "í°ì‚´ ìƒì„ ", difficulty: "easy"},
                {word: "ë„ë¯¸", clue: "ë¹¨ê°„ ìƒì„ ", difficulty: "easy"},
                {word: "ë³µì–´", clue: "ë… ìˆëŠ” ìƒì„ ", difficulty: "easy"},
                {word: "ë‚™ì§€", clue: "ë‹¤ë¦¬ 8ê°œ", difficulty: "easy"},
                {word: "ìƒˆìš°", clue: "êµ¬ë¶€ëŸ¬ì§„ í•´ì‚°ë¬¼", difficulty: "easy"},
                {word: "ê²Œ", clue: "ì§‘ê²Œë°œ", difficulty: "easy"},
                {word: "ì¡°ê°œ", clue: "ê»ë°ê¸° í•´ì‚°ë¬¼", difficulty: "easy"},
                {word: "ì „ë³µ", clue: "ê·€í•œ ì¡°ê°œ", difficulty: "easy"},
                {word: "êµ´", clue: "ë°”ë‹¤ì˜ ìš°ìœ ", difficulty: "easy"},
                {word: "ë©ê²Œ", clue: "ìš¸í‰ë¶ˆí‰ í•´ì‚°ë¬¼", difficulty: "easy"},
                {word: "í•œê¸€", clue: "ìš°ë¦¬ ê¸€ì", difficulty: "easy"},
                {word: "ì„¸ì¢…", clue: "í•œê¸€ ë§Œë“  ì™•", difficulty: "easy"},
                {word: "ì„œìš¸", clue: "ìˆ˜ë„", difficulty: "easy"},
                {word: "ë¶€ì‚°", clue: "ì œ2ë„ì‹œ", difficulty: "easy"},
                {word: "ì¸ì²œ", clue: "ê³µí•­ ë„ì‹œ", difficulty: "easy"},
                {word: "ëŒ€êµ¬", clue: "ê²½ë¶ ì¤‘ì‹¬ë„ì‹œ", difficulty: "easy"},
                {word: "ëŒ€ì „", clue: "ì¶©ì²­ ì¤‘ì‹¬ë„ì‹œ", difficulty: "easy"},
                {word: "ê´‘ì£¼", clue: "ì „ë‚¨ ì¤‘ì‹¬ë„ì‹œ", difficulty: "easy"}
            ];

            extraWords.forEach(word => {
                if (!wordDatabase.some(w => w.word === word.word) &&
                    !apiWords.some(w => w.word === word.word)) {
                    apiWords.push(word);
                }
            });
        }

        // í˜ì´ì§€ ë¡œë“œì‹œ í¼ì¦ ìƒì„±
        window.onload = function() {
            // ê¸°ë³¸ ë‹¨ì–´ ì¶”ê°€ë¡œ API ì—†ì´ë„ ì¶©ë¶„íˆ ì‘ë™
            addFallbackWords();
            generateNewPuzzle();
        };
    </script>

    <!-- Footer with credits -->
    <div style="text-align: center; margin-top: 30px; padding: 20px; color: white; font-size: 12px;">
        <div>
            ğŸ» Developed by <strong>SunnyBear</strong> |
            <a href="https://wonusdwant.tistory.com" target="_blank" style="color: #86efac;">Blog</a> |
            Â© 2025 All Rights Reserved
        </div>
        <div style="margin-top: 10px; opacity: 0.8;">
            ë‹¨ì–´ì˜ ìˆ² (Word Forest) v1.0 | Multi-Cluster Algorithm | Since 2025
        </div>
    </div>
</body>
</html>